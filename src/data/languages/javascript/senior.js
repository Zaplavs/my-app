export default [
  {
    q: "Что такое event loop и как он работает на низком уровне?",
    a: "Event Loop — это механизм, который управляет выполнением кода, обработкой событий и асинхронными операциями в JavaScript. Он состоит из стека вызовов, очередей (callback queue, microtask queue), Web APIs и самого loop'а. После освобождения стека проверяется очередь микрозадач, затем макрозадач. Микрозадачи выполняются приоритетнее."
  },
  {
    q: "Как устроена система прототипов в JavaScript и чем отличается от классического ООП?",
    a: "JavaScript использует прототипное наследование вместо классического ООП. Объект может иметь ссылку на другой объект (`[[Prototype]]`), через которую свойства и методы наследуются. В отличие от классов, нет разделения между классом и экземпляром — всё основано на делегировании через цепочку прототипов."
  },
  {
    q: "Что такое хост-объекты и нативные объекты?",
    a: "Нативные объекты — это те, что определены спецификацией ECMAScript (например, `Object`, `Array`). Хост-объекты предоставляются средой выполнения (браузером или Node.js), например, `window`, `document`, `process`. Их поведение может отличаться в разных окружениях."
  },
  {
    q: "Как работают генераторы и итераторы? Приведите пример использования.",
    a: "Генераторы создаются с помощью `function*` и возвращают итератор. Они могут останавливаться и возобновляться с помощью `yield`. Итераторы реализуют метод `next()`, возвращая `{ value, done }`. Генераторы полезны для управления потоками данных, асинхронности и lazy evaluation."
  },
  {
    q: "Что такое промисификация и как её реализовать?",
    a: "Промисификация — это преобразование функции, принимающей callback, в функцию, возвращающую Promise. Это достигается через оборачивание исходной функции в новый Promise, где resolve и reject передаются как callback. Например, `util.promisify()` в Node.js."
  },
  {
    q: "Чем отличается асинхронная функция от обычной? Какие ошибки возможны при использовании async/await?",
    a: "Асинхронная функция всегда возвращает Promise. Она позволяет использовать `await` для ожидания результата без `.then()`. Ошибки могут быть необработанными, если не использовать try/catch или не добавить `.catch()` к результату функции."
  },
  {
    q: "Что такое Temporal Dead Zone и почему она существует?",
    a: "Temporal Dead Zone (TDZ) — это период времени между началом области видимости и фактическим объявлением переменной через `let` или `const`. Доступ к переменной до объявления вызывает ReferenceError. TDZ существует, чтобы предотвратить использование переменной до её инициализации."
  },
  {
    q: "Как работает движок V8 под капотом?",
    a: "V8 — это JS-движок Chrome и Node.js. Он компилирует JS в машинный код, используя компилятор TurboFan и скрытые классы (Hidden Classes) для оптимизации доступа к свойствам объектов. Также применяются Inline Caching, Garbage Collection (Orinoco) и JIT-компиляция."
  },
  {
    q: "Что такое scope chain и как она формируется?",
    a: "Scope chain — это список областей видимости, используемых функцией при поиске переменных. Формируется во время создания функции и связывает лексическую область видимости. При вызове функции создаётся Execution Context, включающий Variable Environment и ссылку на внешнюю область."
  },
  {
    q: "Что такое this в стрелочных функциях и почему они не имеют собственного this?",
    a: "Стрелочные функции не имеют собственного `this`. Они заимствуют значение `this` из ближайшего лексического контекста. Это удобно в колбэках, но ограничивает их использование в методах объектов и конструкторах."
  },
  {
    q: "Что такое module pattern и какие есть его современные аналоги?",
    a: "Module Pattern — это способ инкапсуляции данных и методов через IIFE, возвращающую API. Современный подход — использование ES6 модулей (`import`/`export`) и Singleton-паттерн через export по умолчанию."
  },
  {
    q: "Как работают Proxy и Reflect? Приведите примеры использования.",
    a: "Proxy позволяет перехватывать операции над объектом (get, set, apply и др.), а Reflect содержит методы, соответствующие этим операциям. Используется для валидации, логирования, реактивности, memoization и т.д. Пример: `new Proxy(obj, { get() {} })`."
  },
  {
    q: "Что такое memory leak и как избежать его в JavaScript?",
    a: "Memory leak — это ситуация, когда память остаётся занятой, хотя уже не используется. Распространённые причины: неочищенные обработчики событий, замыкания, кэширование, интервалы. Избегать можно через удаление ссылок, использование WeakMap/WeakSet, отписку от событий."
  },
  {
    q: "Как работает сборка мусора (garbage collection) в JS?",
    a: "JS использует автоматический GC, основанный на достижимости объектов. Если объект недостижим, он помечается как мусор и удаляется. V8 использует поколенческий GC: молодые объекты очищаются чаще, старые — реже. Есть алгоритмы mark-and-sweep, generational collection."
  },
  {
    q: "Что такое шаблон проектирования Observer и Pub/Sub? В чём разница?",
    a: "Observer — один субъект уведомляет всех наблюдателей. Pub/Sub — есть посредник (event bus), который рассылает сообщения подписчикам. Observer более жёстко связан, Pub/Sub более гибкий и слабо связанный."
  },
  {
    q: "Что такое транспиляция и как она используется в JS?",
    a: "Транспиляция — это преобразование кода из одной версии JS в другую, обычно более старую. Используется Babel для поддержки новых фич в старых движках. Транспиляция может включать полифиллы, преобразование JSX, TypeScript и т.д."
  },
  {
    q: "Что такое шаблон Strategy и когда его использовать?",
    a: "Strategy — поведенческий паттерн, позволяющий выбирать алгоритм выполнения динамически. Полезен, когда нужно менять поведение объекта без изменения его кода. Реализуется через внедрение функции/объекта-стратегии."
  },
  {
    q: "Что такое Liskov Substitution Principle и как он применим к JS?",
    a: "LSP требует, чтобы подклассы могли заменять родительские без нарушения логики программы. В JS, где нет строгих типов, важно следить за совместимостью поведения, особенно при расширении классов или реализации mixin'ов."
  },
  {
    q: "Как работает Webpack под капотом?",
    a: "Webpack анализирует зависимости проекта, начиная с entry point, рекурсивно собирает дерево модулей, применяет загрузчики (loaders) и плагины, затем объединяет их в один или несколько бандлов. Поддерживает code splitting, lazy loading, hot module replacement."
  },
  {
    q: "Что такое Tree Shaking и как он работает?",
    a: "Tree Shaking — это процесс удаления неиспользуемого кода на этапе сборки. Работает с ES6 модулями, так как их импорты/экспорты статичны. Реализован в Rollup, Webpack, Parcel. Требует указания `'sideEffects': false` в package.json."
  },
  {
    q: "Что такое currying и частичное применение? В чём разница?",
    a: "Currying — преобразование функции с N аргументами в последовательность функций с одним аргументом. Частичное применение — создание новой функции с частью аргументов уже заданных. Currying всегда возвращает функцию, частичное применение может сразу вызвать функцию."
  },
  {
    q: "Что такое декораторы в JavaScript и как они используются?",
    a: "Декораторы — это экспериментальная фича, позволяющая изменять поведение классов и их членов через аннотации. Используются в TypeScript, Angular, NestJS. По сути, это функции, которые принимают описание целевого объекта и возвращают новую реализацию."
  },
  {
    q: "Что такое Transpilation и как она отличается от Polyfilling?",
    a: "Transpilation — преобразование кода из одного диалекта JS в другой (например, ES6 → ES5). Polyfilling — добавление реализации новых API в старые движки (например, Promise в IE11). Оба часто используются вместе."
  },
  {
    q: "Как работают Web Workers и в чём их ограничения?",
    a: "Web Workers позволяют выполнять JS в отдельном потоке, не блокируя UI. Не имеют доступа к DOM, `window`, но могут использовать `setTimeout`, `fetch`, `postMessage`. Используются для тяжёлых вычислений."
  },
  {
    q: "Что такое Service Workers и для чего они нужны?",
    a: "Service Worker — это фоновый воркер, который может перехватывать сетевые запросы, кэшировать ресурсы и обеспечивать работу PWA в офлайне. Зарегистрирован как JS-файл, имеет ограниченный доступ к API, но мощные возможности контроля сети и кэша."
  },
  {
    q: "Что такое Virtual DOM и как он работает?",
    a: "Virtual DOM — это легковесная копия реального DOM, используемая библиотеками (React) для минимизации дорогостоящих операций с DOM. При изменении состояния сравнивается новый и старый VDOM, после чего обновляется только то, что действительно изменилось."
  },
  {
    q: "Как работает React reconciliation algorithm?",
    a: "Reconciliation — это процесс сравнения нового дерева VDOM с предыдущим и эффективного обновления реального DOM. Алгоритм использует ключи (`key`), проводит diffing, стараясь свести к минимуму изменения. Использует heuristic O(n) алгоритм."
  },
  {
    q: "Что такое Event Delegation и зачем он нужен?",
    a: "Event Delegation — это техника, при которой обработчик события назначается на родителя, а не на каждый дочерний элемент. Удобно для динамических списков и оптимизации производительности. Используется `event.target` и `event.currentTarget`."
  },
  {
    q: "Что такое HTTP/2 и как он влияет на клиентский JS?",
    a: "HTTP/2 — протокол, поддерживающий множественные параллельные запросы по одному соединению, серверный push, двоичный формат, сжатие заголовков. Позволяет уменьшить latency, улучшает загрузку JS/CSS, делает спрайты менее актуальными."
  },
  {
    q: "Что такое Content Security Policy (CSP) и как он защищает от XSS?",
    a: "CSP — это механизм безопасности, позволяющий ограничить источники, из которых браузер может загружать ресурсы (скрипты, стили и т.д.). Предотвращает инлайновый и reflected XSS, запрещая выполнение произвольного кода."
  }
];