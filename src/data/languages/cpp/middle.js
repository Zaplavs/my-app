export default [
  {
    q: "Что такое класс и объект в C++?",
    a: "Класс — это пользовательский тип данных, который объединяет данные (поля) и функции (методы). Объект — это экземпляр класса. Класс определяет, что объект может хранить и делать, а объект представляет конкретный экземпляр."
  },
  {
    q: "Что такое конструктор и деструктор? Когда они вызываются?",
    a: "Конструктор — это специальный метод, вызываемый при создании объекта для его инициализации. Деструктор — вызывается при уничтожении объекта для освобождения ресурсов. Конструктор вызывается при объявлении объекта, деструктор — при выходе из области видимости или удалении через `delete`."
  },
  {
    q: "Что такое глубокое и поверхностное копирование?",
    a: "Поверхностное копирование (по умолчанию) просто копирует указатели, но не выделяет новую память. Глубокое копирование создаёт новый объект и копирует данные, на которые ссылается исходный объект. Используется, если класс содержит динамически выделенные ресурсы."
  },
  {
    q: "Что такое перегрузка операторов и как её реализовать?",
    a: "Перегрузка операторов позволяет изменить поведение стандартных операторов (`+`, `-`, `=`, `<<` и т.д.) для пользовательских типов. Реализуется через методы класса или внешние функции. Например: `MyClass operator+(const MyClass& other);`"
  },
  {
    q: "Что такое указатель и ссылка? В чём разница между ними?",
    a: "Указатель — это переменная, которая хранит адрес другой переменной. Ссылка — это псевдоним существующей переменной. Указатель можно переустановить, ссылку — нельзя. Указатель может быть `nullptr`, ссылка всегда должна ссылаться на объект."
  },
  {
    q: "Что такое умные указатели и какие вы знаете?",
    a: "Умные указатели — это классы, автоматически управляющие временем жизни динамически выделенных объектов. В STL есть: `std::unique_ptr` (уникальное владение), `std::shared_ptr` (разделяемое владение), `std::weak_ptr` (ненавязчивая ссылка на `shared_ptr`)."
  },
  {
    q: "Что такое std::vector и как он работает внутри?",
    a: "`std::vector` — это динамический массив, который автоматически увеличивает свою ёмкость по мере добавления элементов. При переполнении происходит выделение нового блока памяти и копирование/перемещение старых элементов. Поддерживает произвольный доступ за O(1)."
  },
  {
    q: "Что такое move семантика и как она влияет на производительность?",
    a: "Move семантика позволяет перемещать ресурсы из одного объекта в другой без лишнего копирования. Используется через rvalue reference (`T&&`) и `std::move()`. Повышает производительность, особенно при работе с большими объектами или контейнерами."
  },
  {
    q: "Что такое шаблоны и как их использовать?",
    a: "Шаблоны позволяют писать обобщённый код, который работает с любыми типами. Могут быть функциями или классами. Пример: `template<typename T> T max(T a, T b) { return a > b ? a : b; }`. Шаблоны инстанцируются компилятором для каждого типа."
  },
  {
    q: "Что такое исключения в C++ и как их обрабатывать?",
    a: "Исключения — это механизм обработки ошибок, позволяющий разделить логику программы и обработку ошибок. Выбрасываются через `throw`, перехватываются через `try/catch`. Используется для фатальных ошибок, но требует осторожности из-за сложности управления ресурсами."
  },
  {
    q: "Что такое RAII и как он применяется в C++?",
    a: "RAII (Resource Acquisition Is Initialization) — это идиома, при которой ресурсы захватываются в конструкторе и освобождаются в деструкторе. Это гарантирует корректное освобождение ресурсов даже при выбросе исключений. Примеры: `std::lock_guard`, `std::ifstream`, `std::unique_ptr`."
  },
  {
    q: "Что такое статические члены класса и как к ним обращаться?",
    a: "Статические члены принадлежат всему классу, а не отдельному объекту. Они общие для всех экземпляров. Обращаются через имя класса и оператор разрешения области: `ClassName::memberName`. Инициализируются вне класса, если они не константы."
  },
  {
    q: "Что такое наследование и как его реализовать в C++?",
    a: "Наследование — это возможность одного класса (производного) наследовать поля и методы другого (базового). Позволяет повторно использовать код. Реализуется через `class Derived : public Base`. Поддерживается множественное наследование."
  },
  {
    q: "Что такое виртуальные функции и полиморфизм?",
    a: "Виртуальные функции позволяют переопределять методы в производных классах и вызывать их через указатель или ссылку на базовый класс. Полиморфизм — это способность объекта вести себя по-разному в зависимости от реального типа. Реализуется через таблицы виртуальных функций."
  },
  {
    q: "Что такое интерфейсы в C++ и как их реализовать?",
    a: "В C++ нет ключевого слова `interface`, но интерфейсы реализуются через абстрактные классы с чисто виртуальными функциями: `virtual void func() = 0;`. Класс, наследующий такой интерфейс, должен реализовать все методы."
  },
  {
    q: "Что такое std::string и какие основные методы работы со строками?",
    a: "`std::string` — это класс для работы с текстовыми данными. Основные методы: `size()`, `substr()`, `find()`, `replace()`, `append()`, `c_str()`. Поддерживает оператор `+` для конкатенации и сравнения через `<`, `==`, `!=`."
  },
  {
    q: "Что такое std::map и std::unordered_map? В чём разница?",
    a: "`std::map` — это ассоциативный контейнер, хранящий пары ключ-значение в отсортированном виде (на основе красно-чёрного дерева). `std::unordered_map` — хэш-таблица, быстрее при поиске, но без порядка. Выбор зависит от задачи."
  },
  {
    q: "Что такое алгоритмы STL и как их использовать?",
    a: "Алгоритмы STL — это набор функций, работающих с итераторами. Находятся в заголовочном файле `<algorithm>`. Примеры: `std::sort()`, `std::find()`, `std::transform()`, `std::copy()`. Позволяют работать с любыми контейнерами через итераторы."
  },
  {
    q: "Что такое итераторы и какие виды итераторов вы знаете?",
    a: "Итераторы — это объекты, позволяющие проходить по элементам контейнера. Типы: input, output, forward, bidirectional, random access. `std::vector` поддерживает random access, `std::list` — bidirectional. Используются в циклах и алгоритмах STL."
  },
  {
    q: "Что такое lambda-выражения и как их использовать?",
    a: "Lambda-выражения — это анонимные функции, которые можно определить прямо в месте использования. Синтаксис: `[capture](params) -> return_type { body }`. Часто используются в алгоритмах STL, например: `std::for_each(vec.begin(), vec.end(), [](int x) { cout << x; });`"
  },
  {
    q: "Что такое std::function и std::bind?",
    a: "`std::function` — это обёртка для любого вызываемого объекта (функция, лямбда, функтор). `std::bind` привязывает аргументы к функции, создавая адаптированную версию. Используются вместе для создания callback'ов и хранения функций в контейнерах."
  },
  {
    q: "Что такое потоки в C++ и как их создать?",
    a: "Потоки в C++ реализованы через `std::thread`. Создать поток можно так: `std::thread t(myFunction);`. После запуска нужно вызвать `t.join()` или `t.detach()`. Для синхронизации используются `std::mutex`, `std::atomic`, `std::condition_variable`."
  },
  {
    q: "Что такое мьютексы и как они помогают в многопоточности?",
    a: "Мьютекс (`std::mutex`) используется для защиты общих данных от одновременного доступа из нескольких потоков. Блокировка выполняется через `lock()`, `unlock()` или лучше через `std::lock_guard` или `std::unique_lock`, чтобы избежать deadlock'ов."
  },
  {
    q: "Что такое утечки памяти и как их избежать?",
    a: "Утечка памяти — это ситуация, когда память выделена динамически через `new`, но не освобождена через `delete`. Чтобы избежать утечек, используйте умные указатели (`std::unique_ptr`, `std::shared_ptr`), RAII и проверяйте код с помощью Valgrind, AddressSanitizer."
  },
  {
    q: "Что такое перечисления (enum) и чем отличаются enum class от обычного enum?",
    a: "Enum — это пользовательский тип, состоящий из именованных целочисленных констант. `enum class` имеет область видимости и строгую типизацию. Например: `enum Color { Red, Green };` и `enum class Shape { Circle, Square };`."
  },
  {
    q: "Что такое inline-функции и зачем они нужны?",
    a: "Inline-функции — это функции, которые компилятор может заменить непосредственно в точке вызова, чтобы избежать накладных расходов на вызов. Используются для маленьких часто вызываемых функций. Не гарантирует инлайновое разворачивание, это всего лишь подсказка компилятору."
  },
  {
    q: "Что такое namespaces и зачем они нужны?",
    a: "Namespaces — это пространства имён, которые группируют имена и предотвращают конфликты. Например: `namespace Math { int add(int a, int b); }`. Использование: `Math::add(2, 3);`. Также поддерживают анонимные и вложенные пространства имён."
  },
  {
    q: "Что такое preprocessor directives и какие вы знаете?",
    a: "Препроцессор — это шаг до компиляции, обрабатывающий директивы. Примеры: `#include` (включение файла), `#define` (макросы), `#ifdef/#endif` (условная компиляция). Используется для настройки сборки под разные платформы и режимы."
  },
  {
    q: "Что такое smart pointers и как они управляют памятью?",
    a: "Smart pointers — это классы, управляющие временем жизни динамически выделенных объектов. `std::unique_ptr` — уникальное владение, `std::shared_ptr` — разделяемое владение с подсчётом ссылок, `std::weak_ptr` — слабая ссылка, не увеличивающая счётчик."
  },
  {
    q: "Что такое std::array и как он отличается от обычного массива?",
    a: "`std::array` — это контейнер из STL, который оборачивает обычный статический массив и предоставляет удобный интерфейс. В отличие от C-массива, поддерживает методы вроде `size()`, `empty()`, совместим с STL алгоритмами и безопаснее в использовании."
  }
];