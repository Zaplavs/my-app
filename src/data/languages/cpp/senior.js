export default [
  {
    q: "Что такое RAII и как он используется в C++?",
    a: "RAII (Resource Acquisition Is Initialization) — это идиома управления ресурсами, при которой захват ресурса происходит при создании объекта, а освобождение — при уничтожении. Используется повсеместно в C++ через конструкторы и деструкторы, например: `std::ifstream`, `std::lock_guard`, `std::unique_ptr`."
  },
  {
    q: "Что такое move semantics и rvalue reference? Зачем они нужны?",
    a: "Move semantics позволяет перемещать ресурсы вместо их копирования. Rvalue reference (`T&&`) ссылается на временные объекты. Это позволяет эффективно передавать и возвращать объекты без лишних копирований. Например, `std::move()` преобразует lvalue в rvalue для вызова move-конструктора или move-оператора присваивания."
  },
  {
    q: "Как работает механизм copy elision и что такое Return Value Optimization (RVO)?",
    a: "Copy elision — это оптимизация, при которой компилятор может исключить копирование или перемещение временного объекта. RVO — частный случай, когда возвращаемое значение из функции создаётся непосредственно в принимающей переменной, без промежуточного копирования."
  },
  {
    q: "Что такое SFINAE и как он применяется в шаблонном программировании?",
    a: "`SFINAE` (Substitution Failure Is Not An Error) — это правило, позволяющее отфильтровывать неподходящие шаблоны во время инстанцирования. Используется в выражениях `std::enable_if`, `decltype`, `requires` (C++20), чтобы выбирать подходящую реализацию шаблона в зависимости от типов."
  },
  {
    q: "Что такое perfect forwarding и как он реализуется в C++?",
    a: "Perfect forwarding — это механизм, позволяющий передавать параметры в функции без потери информации о значении (lvalue/rvalue). Реализуется через универсальные ссылки (`T&&`) и `std::forward<T>()`. Применяется в фабричных функциях, лямбдах, контейнерах STL."
  },
  {
    q: "Что такое std::shared_ptr, std::unique_ptr и std::weak_ptr? В чём разница между ними?",
    a: "`std::unique_ptr` — владеющий указатель, не допускающий копирования, только перемещение. `std::shared_ptr` — разделяет владение через подсчёт ссылок. `std::weak_ptr` — не увеличивает счётчик, используется для предотвращения циклических ссылок. Все они обеспечивают безопасное управление памятью."
  },
  {
    q: "Что такое placement new и когда его использовать?",
    a: "`placement new` — это форма оператора `new`, которая создаёт объект в уже выделенной памяти. Используется в случаях, когда нужно контролировать расположение объекта в памяти: например, в custom memory pools, embedded системах или при работе с mmap."
  },
  {
    q: "Что такое memory model в C++ и как он связан с многопоточностью?",
    a: "Memory model — это формальная спецификация того, как потоки взаимодействуют с памятью. Определяет правила видимости изменений между потоками, порядок выполнения и атомарные операции. Важен для предотвращения гонок данных и неопределённого поведения."
  },
  {
    q: "Что такое std::atomic и какие у него уровни согласованности (memory order)?",
    a: "`std::atomic` — это обёртка для атомарных операций над примитивными типами. Поддерживает различные уровни `memory_order`: `relaxed`, `acquire/release`, `seq_cst`. Последний обеспечивает строгую последовательную согласованность, но медленнее."
  },
  {
    q: "Что такое thread_local и где он применяется?",
    a: "`thread_local` — это спецификатор хранения, который гарантирует, что переменная имеет собственный экземпляр в каждом потоке. Используется для хранения состояния, специфичного для потока, например, в пулах соединений, логгерах, TLS."
  },
  {
    q: "Что такое futures и promises в C++? Как работают?",
    a: "`std::future` представляет результат асинхронной операции. `std::promise` устанавливает значение, доступное через future. Используются вместе с `std::async`, `std::packaged_task` для организации межпоточной коммуникации и асинхронного программирования."
  },
  {
    q: "Что такое condition_variable и как она используется в многопоточности?",
    a: "`std::condition_variable` — это примитив синхронизации, используемый вместе с `std::mutex`, чтобы блокировать поток до тех пор, пока другой поток не уведомит его. Часто используется в producer-consumer задачах, очередях сообщений, пулах потоков."
  },
  {
    q: "Что такое template metaprogramming (TMP) и как он используется в C++?",
    a: "Template Metaprogramming — это метод программирования, при котором шаблоны используются для выполнения вычислений на этапе компиляции. TMP применяется в библиотеках вроде Boost.MPL, Eigen, в статических проверках типов и оптимизациях."
  },
  {
    q: "Что такое Concepts в C++20 и зачем они нужны?",
    a: "Concepts — это способ ограничивать типы, которые могут использоваться в шаблонах, делая код более понятным и улучшая диагностику ошибок. Позволяют писать `template<typename T> requires Integral<T>` вместо сложных выражений SFINAE."
  },
  {
    q: "Что такое ranges в C++20 и как они отличаются от итераторов?",
    a: "Ranges — это абстракция для работы с последовательностями, объединяющая начало и конец в один объект. Они поддерживают pipeline-стиль и удобные view-адаптеры, такие как `views::filter`, `views::transform`. Упрощают работу с алгоритмами и улучшают читаемость кода."
  },
  {
    q: "Что такое coroutines в C++20 и как они используются?",
    a: "Coroutines — это функции, которые могут приостанавливать своё выполнение и продолжать позже. Используются для реализации асинхронного кода, генераторов, state machines. Требуют реализации promise type и co_await/co_yield. Поддерживаются в MSVC, Clang, GCC."
  },
  {
    q: "Что такое Undefined Behavior и почему важно его избегать?",
    a: "Undefined Behavior — это ситуация, когда программа делает то, что не определено стандартом C++. Результат может быть любым: от правильной работы до сбоя. Примеры: выход за границы массива, использование dangling pointer, signed overflow. UB сложно отладить и должен быть исключён."
  },
  {
    q: "Что такое ABI и как он влияет на совместимость библиотек?",
    a: "ABI (Application Binary Interface) — это соглашение о том, как данные представлены в памяти, как вызываются функции, как обрабатываются исключения. Несовместимость ABI между компиляторами или версиями STL может привести к проблемам при связывании и запуске библиотек."
  },
  {
    q: "Что такое static_assert и как он используется?",
    a: "`static_assert` — это проверка времени компиляции. Если условие ложно, компиляция завершается с ошибкой. Используется для проверки размеров типов, корректности шаблонных параметров, требований к типам."
  },
  {
    q: "Что такое CRTP и где он применяется?",
    a: "CRTP (Curiously Recurring Template Pattern) — это паттерн, при котором базовый класс принимает производный как параметр шаблона. Позволяет эмулировать виртуальные вызовы без runtime overhead. Используется в библиотеках вроде Eigen, Boost."
  },
  {
    q: "Что такое Rule of Three/Five/Zero в C++?",
    a: "Правило трёх: если класс определяет один из: деструктор, копирующий конструктор или оператор присваивания, то, скорее всего, нужно определить все три. Правило пяти добавляет move-конструктор и move-оператор. Правило ноль: если всё можно оставить по умолчанию, не определяйте ничего."
  },
  {
    q: "Что такое noexcept и как он влияет на производительность и безопасность?",
    a: "`noexcept` гарантирует, что функция не будет бросать исключений. Это позволяет компилятору делать оптимизации (например, move вместо copy). Также используется в STL для проверки, можно ли безопасно перемещать типы в контейнеры."
  },
  {
    q: "Что такое constexpr и consteval? В чём разница?",
    a: "`constexpr` — выражение или функция, которая может быть вычислена на этапе компиляции. `consteval` — функция, которая **должна** быть вычислена на этапе компиляции. `consteval` используется для compile-time only вычислений."
  },
  {
    q: "Что такое allocators в STL и как их использовать?",
    a: "Allocator — это шаблонный параметр контейнеров STL, определяющий, как выделять и освобождать память. Стандартный `std::allocator` использует `new/delete`. Можно написать свой allocator для использования custom memory pools, arena allocation и т.д."
  },
  {
    q: "Что такое intrusive containers и чем они отличаются от STL-контейнеров?",
    a: "Intrusive containers (например, из Boost.Intrusive) требуют, чтобы элемент сам хранил информацию о своих связях в списке/дереве. Это даёт лучшую производительность и детерминированность, но требует изменения структуры данных."
  },
  {
    q: "Что такое PIMPL и зачем он нужен?",
    a: "PIMPL (Pointer to IMPLementation) — это идиома, при которой реализация класса скрывается в отдельном объекте, на который указывает указатель. Уменьшает зависимость заголовочных файлов, ускоряет сборку и позволяет менять реализацию без перекомпиляции интерфейса."
  },
  {
    q: "Что такое Undefined, Unspecified и Implementation Defined Behavior?",
    a: "UB — неопределённое поведение, может быть любым. Unspecified — поведение зависит от реализации, но документировано. Implementation-defined — явно задокументировано, как ведёт себя конкретная реализация. Разработчики должны избегать UB и знать различия между остальными."
  },
  {
    q: "Что такое ABI и как его тестировать между версиями библиотек?",
    a: "ABI (Application Binary Interface) — это соглашение о представлении данных и вызовах функций. Чтобы проверить совместимость, можно использовать утилиты вроде `abi-compliance-checker`, `readelf`, `nm`, `objdump`. Также важно использовать `extern 'C'` для C-like API."
  },
  {
    q: "Что такое linker и какие ошибки он может выдавать?",
    a: "Linker — это часть компилятора, которая связывает объектные файлы в исполняемый файл. Распространённые ошибки: `undefined reference` (не найден символ), `multiple definition` (повторное определение), `unresolved external symbol`. Обычно возникают при неверной компоновке библиотек."
  },
  {
    q: "Что такое ODR и как он применяется в C++?",
    a: "ODR (One Definition Rule) — это правило, которое требует, чтобы любая переменная, функция, класс имели одну и только одну определённую реализацию в программе. Нарушение ODR приводит к undefined behavior."
  }
];