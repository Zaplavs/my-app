export default [
  {
    q: "Что такое JVM и как она устроена под капотом?",
    a: "JVM (Java Virtual Machine) — это виртуальная машина, которая выполняет байткод. Состоит из класслоадера, рантайм пулов памяти (heap, stack, metaspace), execution engine (интерпретатор, JIT компилятор), garbage collector. Класслоадер загружает классы, JIT компилирует часто исполняемый байткод в машинный код для повышения производительности."
  },
  {
    q: "Как работает Garbage Collection в JVM? Какие типы сборщиков вы знаете?",
    a: "GC отвечает за автоматическое освобождение памяти. В основе лежит достижимость объектов от GC Roots. Типы сборщиков: Serial, Parallel, CMS (устарел), G1 (по умолчанию), ZGC и Shenandoah (низкая задержка). Выбор зависит от SLA приложения: пропускная способность vs задержки."
  },
  {
    q: "Что такое JIT-компиляция и как она влияет на производительность?",
    a: "JIT (Just-In-Time) — это механизм динамической компиляции байткода в нативный код во время выполнения программы. Позволяет оптимизировать «горячие» участки кода. Работает через профилирование, встраивание методов, устранение синхронизации и другие техники."
  },
  {
    q: "Что такое Java Memory Model и почему она важна?",
    a: "Java Memory Model (JMM) — это набор правил, регулирующих видимость изменений между потоками. Определяет, когда изменения одного потока становятся видны другим. Используются ключевые слова `volatile`, `synchronized`, и блокировки `java.util.concurrent.locks`. Без JMM возможны гонки данных и неопределённое поведение."
  },
  {
    q: "Что такое escape analysis и как он влияет на производительность?",
    a: "Escape Analysis — это анализ, определяющий, может ли объект 'выбежать' за пределы текущего метода или потока. Если нет, то JVM может применить оптимизации: скаляризация объекта (разложение на примитивы) и аллокация на стеке вместо кучи, что снижает нагрузку на GC."
  },
  {
    q: "Как работают потоки в Java? Что такое thread pool и зачем он нужен?",
    a: "Потоки в Java реализуются через `Thread` и `Runnable`. Thread Pool — это управляемый набор потоков, готовых выполнять задачи. Он позволяет избежать накладных расходов на создание/удаление потоков. Используется через `ExecutorService`, например `Executors.newFixedThreadPool()`."
  },
  {
    q: "Что такое Fork/Join Framework и когда его использовать?",
    a: "Fork/Join — это реализация divide-and-conquer подхода для параллельной обработки данных. Основан на рекурсивном разделении задачи (`fork()`) и объединении результатов (`join()`). Используется с `ForkJoinPool`. Подходит для CPU-интенсивных задач, таких как сортировка, обработка деревьев."
  },
  {
    q: "Что такое CompletableFuture и как он отличается от Future?",
    a: "`CompletableFuture` — это расширение интерфейса `Future`, позволяющее комбинировать асинхронные операции, цепочки действий, обработку ошибок и обмен данными между задачами. В отличие от `Future`, он поддерживает callback'и и compose/thenApply/exceptionally и т.д."
  },
  {
    q: "Что такое Amdahl's Law и Gustafson's Law?",
    a: "Amdahl's Law показывает, насколько можно ускорить программу при использовании параллелизма, исходя из доли последовательного кода. Gustafson's Law учитывает масштабируемость задачи — чем больше процессоров, тем больше можно обработать данных. Оба закона важны при оценке эффективности многопоточных приложений."
  },
  {
    q: "Что такое Deadlock, Livelock, Starvation и как их диагностировать?",
    a: "Deadlock — все потоки ждут друг друга. Livelock — потоки активно работают, но не продвигаются. Starvation — поток никогда не получает ресурсы. Диагностируются через `jstack`, VisualVM, Thread Dump, где видно состояние потоков и захваченные мониторы."
  },
  {
    q: "Что такое CAS (Compare and Swap)? Где применяется?",
    a: "CAS — это атомарная операция, которая проверяет значение переменной и меняет его, если оно совпадает с ожидаемым. Применяется в `AtomicInteger`, `ConcurrentHashMap`, безблокирующих алгоритмах. Позволяет избежать использования `synchronized` и повысить производительность."
  },
  {
    q: "Что такое volatile и как он работает?",
    a: "Ключевое слово `volatile` гарантирует, что значение переменной всегда читается из основной памяти, а не из кэша процессора. Также обеспечивает частичную упорядоченность операций чтения/записи. Не является атомарным, но помогает в случае однократной записи и множественного чтения."
  },
  {
    q: "Что такое memory barrier и как он связан с volatile?",
    a: "Memory Barrier (fence) — это инструкция процессора, ограничивающая переупорядочивание операций чтения/записи. При использовании `volatile` вставляются специальные memory barriers, чтобы обеспечить корректную видимость изменений между потоками."
  },
  {
    q: "Что такое classloader и какие типы существуют?",
    a: "Classloader — это часть JVM, которая загружает классы по требованию. Типы: Bootstrap (загружает rt.jar), Extension (расширения), Application (классы из classpath). Можно реализовать свой ClassLoader для динамической загрузки классов, например, в OSGi или контейнерах."
  },
  {
    q: "Что такое PermGen и Metaspace? Чем они отличаются?",
    a: "PermGen (до Java 8) — область памяти, где хранились метаданные классов. Был ограничен и мог вызывать OutOfMemoryError. Metaspace (с Java 8) хранит метаданные в native memory и увеличивается по мере необходимости, что улучшает стабильность и производительность."
  },
  {
    q: "Что такое Java Agent и Instrumentation API?",
    a: "Java Agent — это механизм, позволяющий модифицировать классы в runtime до их загрузки. Используется в профайлерах, тестовых фреймворках, AOP. Через `Instrumentation API` можно добавлять ClassFileTransformers и менять байткод."
  },
  {
    q: "Что такое Bytecode Manipulation и где применяется?",
    a: "Bytecode manipulation — это изменение байткода классов в runtime или compile-time. Используется в Hibernate (прокси), Spring AOP, Mockito, MapStruct и других фреймворках. Инструменты: ASM, ByteBuddy, Javassist."
  },
  {
    q: "Что такое SOLID и как они применяются в Java?",
    a: "SOLID — 5 принципов проектирования: **S**ingle Responsibility, **O**pen/Closed, **L**iskov Substitution, **I**nterface Segregation, **D**ependency Inversion. Применяются для создания гибкой, тестируемой и легко поддерживаемой архитектуры. Например, Open/Closed достигается через Strategy Pattern, DIP — через внедрение зависимостей."
  },
  {
    q: "Что такое DRY, KISS и YAGNI? Как они влияют на проектирование?",
    a: "DRY (Don’t Repeat Yourself) — избегать дублирования кода. KISS (Keep It Simple Stupid) — проектировать максимально просто. YAGNI (You Aren't Gonna Need It) — не добавлять функционал, который пока не требуется. Эти принципы помогают писать чистый, понятный и поддерживаемый код."
  },
  {
    q: "Что такое CQRS и Event Sourcing? Когда их использовать?",
    a: "CQRS (Command Query Responsibility Segregation) разделяет модель команд и запросов. Event Sourcing сохраняет изменения состояния в виде потока событий. Используются вместе в системах с высокими требованиями к аудиту, восстановлению и горизонтальным шкалами."
  },
  {
    q: "Что такое Hexagonal Architecture и как её реализовать в Java?",
    a: "Hexagonal Architecture (Ports & Adapters) — архитектура, отделяющая бизнес-логику от внешних деталей (БД, UI, REST). Реализуется через порты (интерфейсы), адаптеры (реализации), доменную модель. Удобна для тестирования и замены слоёв."
  },
  {
    q: "Что такое Domain-Driven Design и как он применяется?",
    a: "DDD — это подход к проектированию сложных систем через моделирование предметной области. Основные концепции: Aggregate Root, Value Object, Entity, Repository, Service, Bounded Context. Применяется в микросервисных архитектурах для разделения зон ответственности."
  },
  {
    q: "Что такое Dependency Injection и как он реализован в Spring?",
    a: "DI — это паттерн, позволяющий передавать зависимости объекта извне. В Spring DI реализуется через аннотации (`@Autowired`, `@Inject`) и конфигурации. Spring IoC контейнер управляет жизненным циклом бинов и их связями."
  },
  {
    q: "Что такое Spring Boot и чем он отличается от Spring Framework?",
    a: "Spring Boot — это надстройка над Spring Framework, предоставляющая автоконфигурацию, embedded сервер, starter'ы и простую настройку. Упрощает создание standalone и production-ready приложений без XML-конфигураций."
  },
  {
    q: "Что такое Spring AOP и как он работает?",
    a: "Spring AOP — реализация аспектно-ориентированного программирования. Позволяет вынести перекрёстные Concerns (логирование, безопасность) в отдельные аспекты. Реализуется через proxy-объекты (JDK Dynamic Proxy или CGLIB)."
  },
  {
    q: "Что такое REST и как реализовать REST API в Spring?",
    a: "REST (Representational State Transfer) — стиль архитектуры для создания веб-сервисов. В Spring используется `@RestController`, `@RequestMapping`, `@GetMapping`, `@PostMapping`. Также можно использовать Swagger/OpenAPI для документации."
  },
  {
    q: "Что такое Circuit Breaker и как он реализуется в Java?",
    a: "Circuit Breaker — паттерн для защиты от сбоев в распределённых системах. Реализуется через библиотеки вроде Resilience4j или Hystrix. Переключает поведение на fallback, если сервис недоступен, чтобы избежать cascading failures."
  },
  {
    q: "Что такое Microservices и какие проблемы они решают?",
    a: "Микросервисы — это архитектура, при которой приложение состоит из множества независимо развертываемых сервисов. Решает проблемы масштабируемости, сложности, монолита. Требует управления сервисами, коммуникацией, отказоустойчивостью и мониторингом."
  },
  {
    q: "Что такое CI/CD и как его реализовать для Java-приложений?",
    a: "CI/CD — практики автоматизации сборки, тестирования и деплоя. Для Java: Maven/Gradle (CI), Jenkins/GitLab CI (orchestration), Docker/Kubernetes (CD). Автоматизация позволяет быстро и безопасно доставлять изменения в production."
  },
  {
    q: "Что такое profiling и какие инструменты вы знаете для Java?",
    a: "Profiling — анализ производительности приложения: CPU, память, GC. Инструменты: JProfiler, YourKit, VisualVM, Async Profiler, Flight Recorder (JFR). Профилирование помогает находить узкие места и оптимизировать код."
  }
];