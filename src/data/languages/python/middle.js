export default [
  {
    q: "Что такое GIL и как он влияет на производительность многопоточных приложений в Python?",
    a: "GIL (Global Interpreter Lock) — это механизм в CPython, который позволяет только одному потоку выполняться одновременно. Это ограничивает эффективность CPU-bound многопоточных программ. Однако для I/O-bound задач (например, работа с сетью или диском), GIL освобождается, и потоки могут работать параллельно."
  },
  {
    q: "Как работает garbage collection в Python? Какие поколения сборки мусора существуют?",
    a: "В Python используется алгоритм reference counting для подсчёта ссылок и дополнительный generational garbage collector для обнаружения циклических ссылок. Сборка мусора делится на три поколения: объекты, выжившие в первом поколении, переходят во второе и третье, где проверяются реже. Это улучшает производительность GC."
  },
  {
    q: "Чем отличаются процессы и потоки в Python? Когда что использовать?",
    a: "Процессы имеют собственное пространство памяти и не разделяют данные по умолчанию, поэтому они подходят для CPU-bound задач, где важно использовать все ядра процессора. Потоки разделяют память, но из-за GIL не дают параллелизма для CPU-bound задач. Они полезны для I/O-bound операций (сетевые запросы, чтение/запись файлов)."
  },
  {
    q: "Как работает декоратор в Python? Приведите пример создания собственного декоратора.",
    a: "Декоратор — это функция, которая принимает другую функцию и расширяет её поведение без изменения её кода. Пример декоратора:\n\nfunction def my_decorator(func):\n    def wrapper():\n        print('Before function call')\n        func()\n        print('After function call')\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print('Hello')\n\nsay_hello()"
  },
  {
    q: "Что такое контекстные менеджеры и как их использовать в Python?",
    a: "Контекстные менеджеры позволяют выделять и освобождать ресурсы безопасным образом. Чаще всего используются через конструкцию with. Например, при работе с файлами: with open('file.txt', 'r') as f: content = f.read(). Контекстный менеджер гарантирует закрытие файла даже при возникновении ошибки."
  },
  {
    q: "Как реализовать класс с использованием ООП в Python? Что такое инкапсуляция, наследование и полиморфизм?",
    a: "Инкапсуляция — скрытие деталей реализации и предоставление интерфейса. Наследование — создание нового класса на основе существующего. Полиморфизм — возможность объектов разных классов иметь методы с одинаковым названием, но разной реализацией.\n\nПример:\n\nclass Animal:\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return 'Woof'\n\ndog = Dog()\nprint(dog.speak())"
  },
  {
    q: "Что такое дескрипторы в Python и зачем они нужны?",
    a: "Дескрипторы — это объекты, которые определяют поведение при доступе к атрибутам другого объекта. Они реализуются через методы __get__, __set__ и __delete__. Дескрипторы часто используются для создания свойств, валидации данных и реализации сложного поведения атрибутов."
  },
  {
    q: "Как работают метаклассы в Python? Для чего они применяются?",
    a: "Метакласс — это класс, экземплярами которого являются другие классы. По умолчанию используется type. Метаклассы позволяют изменить логику создания классов, например, добавлять атрибуты, проверять условия или регистрировать классы. Используются в продвинутых фреймворках, таких как Django или SQLAlchemy."
  },
  {
    q: "Что такое dunder-методы и как они используются в Python?",
    a: "Dunder-методы (double underscore methods) — это специальные методы, начинающиеся и заканчивающиеся двойным подчёркиванием, такие как __init__, __str__, __repr__, __len__. Они определяют поведение объектов встроенных операций, например, при вызове len(), str() или операторах сравнения."
  },
  {
    q: "Как работает сериализация и десериализация в Python? Расскажите про json и pickle.",
    a: "JSON — текстовый формат, удобный для передачи данных между клиентом и сервером. В Python используется модуль json для преобразования в/из строк. Pickle — бинарный формат сериализации Python-объектов, сохраняет типы и структуры, но небезопасен для загрузки данных из непроверенных источников."
  },
  {
    q: "Что такое генераторы и чем они отличаются от обычных функций?",
    a: "Генераторы — это функции, которые возвращают последовательность значений с помощью ключевого слова yield вместо return. Генераторы экономят память, так как не хранят весь набор данных сразу, а возвращают значения по одному. Это особенно полезно для работы с большими объёмами данных."
  },
  {
    q: "Что такое итераторы и итерируемые объекты в Python?",
    a: "Итерируемый объект — это объект, который может быть передан в цикл for. Он должен возвращать итератор при вызове iter(). Итератор — это объект, который реализует метод __next__ и возвращает следующий элемент последовательности. Когда элементы заканчиваются, выбрасывается StopIteration."
  },
  {
    q: "Как работают замыкания в Python?",
    a: "Замыкание — это функция, которая запоминает значения из окружающей области видимости, даже если эта область больше не существует. Замыкания часто используются в декораторах, каррировании и частичном применении функций."
  },
  {
    q: "Что такое functools.lru_cache и как его использовать?",
    a: "functools.lru_cache — это декоратор, который кэширует результаты вызова функции на основе её аргументов. Это очень полезно для рекурсивных функций или функций с повторяющимися входными данными, таких как вычисление чисел Фибоначчи. Он значительно повышает производительность за счёт кэширования."
  },
  {
    q: "Как работает глубокое и поверхностное копирование объектов в Python?",
    a: "Поверхностное копирование (copy.copy()) создаёт новый объект, но вложенные объекты остаются теми же ссылками. Глубокое копирование (copy.deepcopy()) рекурсивно копирует все вложенные объекты. Это важно при работе со списками или словарями, содержащими изменяемые типы."
  },
  {
    q: "Что такое property в Python и как его использовать?",
    a: "property — это способ контролировать доступ к атрибутам класса. Он позволяет определить getter, setter и deleter для атрибута, чтобы добавить логику валидации или вычисления. Реализуется через декоратор @property или функцию property()."
  },
  {
    q: "Как работают регулярные выражения в Python? Какие основные методы модуля re?",
    a: "Регулярные выражения позволяют искать и обрабатывать строки по шаблонам. Основные методы модуля re: re.match() (поиск в начале строки), re.search() (поиск в любой части строки), re.findall() (все совпадения), re.sub() (замена)."
  },
  {
    q: "Что такое virtual environment и зачем он нужен?",
    a: "Virtual environment — это изолированная среда для проекта, в которой можно устанавливать зависимости, не влияя на глобальную установку Python. Он позволяет избежать конфликтов версий библиотек между проектами. Создается с помощью venv или virtualenv."
  },
  {
    q: "Как работает система импорта в Python? Что такое относительные и абсолютные импорты?",
    a: "Абсолютные импорты указывают полный путь от корня проекта, например from package.submodule import module. Относительные импорты используют точку для обозначения текущего или родительского модуля, например from . import module. Относительные импорты работают только внутри пакетов."
  },
  {
    q: "Что такое MRO (Method Resolution Order) в Python и как он работает?",
    a: "MRO — это порядок, в котором Python ищет методы в иерархии наследования. В Python используется алгоритм C3 linearization, который обеспечивает предсказуемый порядок поиска. Вы можете посмотреть MRO с помощью метода ClassName.mro() или атрибута __mro__."
  },
  {
    q: "Как работают асинхронные функции и async/await в Python?",
    a: "Асинхронные функции объявляются с помощью async def и возвращают coroutine-объект. Ключевое слово await приостанавливает выполнение функции до завершения другой coroutine. Асинхронность позволяет выполнять I/O-bound операции параллельно без блокировки основного потока."
  },
  {
    q: "Что такое динамическая типизация в Python? Как она влияет на разработку?",
    a: "В Python переменные не имеют строго заданного типа — тип определяется в момент присвоения значения. Это упрощает написание кода, но требует внимания, так как ошибки могут быть найдены только на этапе выполнения. Для улучшения читаемости и поддержки можно использовать type hints."
  },
  {
    q: "Как работают type hints в Python? Зачем они нужны?",
    a: "Type hints — это аннотации типов, которые помогают лучше понимать, какие типы данных ожидает функция или переменная. Они не влияют на выполнение программы, но улучшают читаемость, документацию и позволяют использовать статические анализаторы, такие как mypy."
  },
  {
    q: "Как работает функция zip()? Какие у неё ограничения?",
    a: "Функция zip() объединяет несколько итерируемых объектов в кортежи по индексам. Она останавливается, когда самый короткий итерируемый объект закончится. Например, zip([1,2], ['a','b']) вернёт [(1,'a'), (2,'b')]. Чтобы продолжить до самого длинного, используйте itertools.zip_longest."
  },
  {
    q: "Как работают map() и filter() в Python?",
    a: "map() применяет функцию ко всем элементам итерируемого объекта и возвращает итератор с результатами. filter() фильтрует элементы по условию, переданному в виде функции. Обе функции часто заменяются генераторами списков для лучшей читаемости."
  },
  {
    q: "Как управлять зависимостями в проекте? Что такое requirements.txt и Pipfile?",
    a: "requirements.txt — текстовый файл, перечисляющий зависимости проекта с указанием версий. Он создаётся с помощью pip freeze > requirements.txt и используется для установки зависимостей: pip install -r requirements.txt. Pipfile — более современный формат, управляемый с помощью pipenv, который автоматически отслеживает зависимости и окружение."
  },
  {
    q: "Что такое unit-тесты и как их писать в Python?",
    a: "Unit-тесты — это тесты для проверки отдельных модулей или функций. В Python есть встроенный модуль unittest. Тесты пишутся в отдельном файле, наследующемся от unittest.TestCase, и содержат методы, начинающиеся с test_. Также популярны pytest и doctest."
  },
  {
    q: "Как работает сериализация с помощью pickle и почему она может быть опасной?",
    a: "Pickle сериализует и десериализует Python-объекты в байтовую строку. Он удобен для сохранения состояния объектов, но небезопасен: загрузка данных из непроверенных источников может привести к выполнению произвольного кода. Поэтому pickle не рекомендуется использовать для обмена данными с внешними системами."
  },
  {
    q: "Что такое monkey patching и в каких случаях он используется?",
    a: "Monkey patching — это практика изменения или расширения поведения модулей или классов во время выполнения без изменения исходного кода. Иногда используется в тестировании или легаси-проектах, но считается плохой практикой, так как затрудняет отладку и понимание кода."
  }
];