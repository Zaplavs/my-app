export default [
  {
    q: "Как работает GIL в Python и можно ли его отключить? Как обойти его ограничения?",
    a: "GIL (Global Interpreter Lock) — это блокировка в CPython, которая позволяет только одному потоку выполняться в один момент времени. Это ограничивает производительность CPU-bound многопоточных приложений. GIL нельзя полностью отключить в стандартном CPython, но можно обойти его ограничения с помощью multiprocessing (процессы), C-расширений (например, NumPy) или использования Jython/PyPy (альтернативные реализации)."
  },
  {
    q: "Как устроена внутренняя реализация словарей (dict) в Python? Почему они так быстры?",
    a: "Словари в Python реализованы на основе хэш-таблиц. Ключ хэшируется, и результат используется как индекс для хранения значения в массиве. Это позволяет получать элементы за O(1) в среднем. Python оптимизирует словари для быстрого доступа, используя открытую адресацию и динамическое расширение таблицы при переполнении."
  },
  {
    q: "Что такое CPython, PyPy, Jython, Cython? В чём их основные отличия?",
    a: "CPython — стандартная реализация Python на C. PyPy — альтернативная реализация с JIT-компилятором, которая ускоряет выполнение кода. Jython — реализация Python на Java, работающая на JVM. Cython — это надстройка над Python, которая компилируется в C и позволяет создавать расширения для Python, значительно ускоряя критические участки кода."
  },
  {
    q: "Как работает асинхронный ввод-вывод в Python? Что такое event loop и как с ним работать?",
    a: "Асинхронный ввод-вывод в Python реализуется через event loop — цикл событий, который управляет выполнением асинхронных задач. async/await позволяет писать асинхронный код, похожий на синхронный. Event loop запускается с помощью asyncio.run(), и в нём можно создавать задачи (create_task), ожидать их выполнения (await) и управлять параллелизмом."
  },
  {
    q: "Как работает сериализация и десериализация в Python? Чем отличаются pickle, json и marshal?",
    a: "Pickle — бинарная сериализация Python-объектов, поддерживает сложные типы, но небезопасен. JSON — текстовый формат, удобен для обмена данными между языками. Marshal — внутренний формат Python, используется для сериализации кода (например, .pyc-файлов), не предназначен для общего использования."
  },
  {
    q: "Что такое дескрипторы и как они используются в Python? Приведите пример.",
    a: "Дескрипторы — это объекты, которые управляют доступом к атрибутам другого объекта. Они реализуют методы __get__, __set__ и __delete__. Примеры использования: property, classmethod, staticmethod. Пример дескриптора:\n\nclass Descriptor:\n    def __get__(self, instance, owner):\n        return 42\n\nclass MyClass:\n    x = Descriptor()\n\nobj = MyClass()\nprint(obj.x)  # выводит 42"
  },
  {
    q: "Что такое метаклассы и в каких случаях они используются?",
    a: "Метакласс — это класс, экземплярами которого являются другие классы. По умолчанию используется type. Метаклассы используются для автоматической настройки классов при создании, например, для регистрации классов, проверки атрибутов или реализации ORM. Пример: Django ORM, SQLAlchemy."
  },
  {
    q: "Как работает garbage collector в Python? Какие поколения сборки мусора существуют и как они работают?",
    a: "В Python garbage collector использует reference counting и generational сборку для циклических ссылок. Объекты делятся на три поколения: 0 (новые), 1 и 2 (старые). Чем старше поколение, тем реже оно проверяется. Это позволяет эффективно управлять памятью, не проверяя все объекты каждый раз."
  },
  {
    q: "Как работает интерпретатор Python под капотом? Опишите этапы выполнения кода.",
    a: "Этапы выполнения Python-кода:\n1. Лексический анализ (разбор на токены)\n2. Синтаксический анализ (создание AST)\n3. Компиляция в байт-код\n4. Выполнение байт-кода виртуальной машиной CPython\nБайт-код хранится в .pyc-файлах для ускорения повторного запуска."
  },
  {
    q: "Как управлять памятью в Python? Что такое pymalloc и как он работает?",
    a: "Python управляет памятью через встроенный менеджер памяти, который использует pymalloc — специализированный аллокатор для маленьких объектов. Он оптимизирован для частого выделения и освобождения памяти, что улучшает производительность. pymalloc использует пулы и блоки для эффективного управления памятью."
  },
  {
    q: "Какие существуют методы профилирования и оптимизации производительности Python-приложений?",
    a: "Для профилирования используются: cProfile, timeit, memory_profiler, line_profiler. Для оптимизации:\n- Использование встроенных функций и генераторов\n- Ускорение критических участков с помощью Cython или Numba\n- Использование NumPy для векторизации\n- Уменьшение количества вызовов в циклах\n- Асинхронность для I/O-bound задач"
  },
  {
    q: "Как работает functools.lru_cache и какие у него ограничения?",
    a: "functools.lru_cache — это декоратор, который кэширует результаты вызова функции на основе её аргументов. Он особенно полезен для рекурсивных функций. Ограничения: работает только с хэшируемыми аргументами, может потреблять много памяти. Для контроля размера кэша можно указать maxsize."
  },
  {
    q: "Что такое monkey patching и в каких случаях он применяется? Почему его лучше избегать?",
    a: "Monkey patching — это изменение поведения классов или модулей во время выполнения без изменения их исходного кода. Применяется в тестировании, легаси-коде и фреймворках. Однако его лучше избегать, так как он делает код трудным для понимания, отладки и поддержки, нарушая принцип открытости/закрытости."
  },
  {
    q: "Как работает сериализация объектов с помощью __getstate__ и __setstate__?",
    a: "Метод __getstate__ определяет, как будет сериализован объект. __setstate__ восстанавливает объект из сериализованного состояния. Эти методы позволяют контролировать, какие данные сохранять и как их восстанавливать. Пример:\n\nclass MyClass:\n    def __getstate__(self):\n        return {'important_data': self.important_data}\n\n    def __setstate__(self, state):\n        self.important_data = state['important_data']"
  },
  {
    q: "Что такое weakref и когда его использовать?",
    a: "weakref — это слабая ссылка на объект, которая не увеличивает счётчик ссылок. Это позволяет избежать циклических ссылок и утечек памяти. Используется, например, в кэшах, подписках или словарях, где важно не удерживать объект, если он больше не нужен."
  },
  {
    q: "Как работает functools.singledispatch и зачем он нужен?",
    a: "functools.singledispatch позволяет создавать функции, поведение которых зависит от типа первого аргумента. Это реализация функциональной перегрузки в Python. Пример:\n\nfrom functools import singledispatch\n\n@singledispatch\ndef process(data):\n    raise NotImplementedError()\n\n@process.register(int)\ndef _(data):\n    return f'Processing integer: {data}'"
  },
  {
    q: "Как работает asyncio и какие у него ограничения?",
    a: "asyncio — это фреймворк для написания асинхронного кода с использованием async/await. Он основан на event loop и coroutines. Ограничения: не даёт параллелизма CPU-bound задач, блокирующий код может остановить весь event loop, требуется аккуратная обработка исключений и отладка."
  },
  {
    q: "Что такое context manager и как его реализовать через __enter__ и __exit__?",
    a: "Context manager — это объект, который управляет ресурсами (например, файлами или соединениями) с помощью конструкции with. Он реализуется через методы __enter__ (подготавливает ресурс) и __exit__ (очищает его). Пример:\n\nclass MyContext:\n    def __enter__(self):\n        print('Setup')\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print('Teardown')"
  },
  {
    q: "Как работают type hints и что такое typing.TypedDict, typing.Protocol, typing.Generator?",
    a: "Type hints — аннотации типов, помогающие читать и проверять код. TypedDict — для аннотации словарей с известными ключами. Protocol — для структурной типизации (duck typing). Generator — для аннотации генераторов с указанием возвращаемых типов и возвращаемого значения."
  },
  {
    q: "Какие существуют паттерны проектирования в Python? Приведите примеры их реализации.",
    a: "Популярные паттерны:\n- Singleton — гарантирует наличие только одного экземпляра класса\n- Factory — создаёт объекты без указания конкретного класса\n- Observer — реализует механизм подписки на события\n- Strategy — позволяет динамически менять алгоритмы\n- Decorator — добавляет поведение без изменения класса"
  },
  {
    q: "Как работает garbage collector при наличии циклических ссылок?",
    a: "Reference counting не может обрабатывать циклические ссылки, поэтому Python использует generational garbage collector для их обнаружения и удаления. GC анализирует граф объектов, ищет недостижимые циклы и удаляет их. Это происходит в фоне, при достижении порога для каждого поколения."
  },
  {
    q: "Как реализовать пул потоков или процессов в Python?",
    a: "Для пула потоков используется concurrent.futures.ThreadPoolExecutor, для процессов — ProcessPoolExecutor. Пример:\n\nfrom concurrent.futures import ThreadPoolExecutor\n\ndef task(n):\n    return n * n\n\nwith ThreadPoolExecutor() as executor:\n    results = list(executor.map(task, range(5)))"
  },
  {
    q: "Как работают __slots__ и зачем они нужны?",
    a: "__slots__ позволяет явно указать, какие атрибуты может иметь класс, экономя память и ускоряя доступ к атрибутам. Он также предотвращает добавление случайных атрибутов. Используется в классах, где важна производительность и память, например, в DTO или моделях ORM."
  },
  {
    q: "Что такое ABC и как реализовать абстрактный класс в Python?",
    a: "ABC (Abstract Base Class) — базовый класс, который может содержать абстрактные методы. Абстрактный метод должен быть реализован в дочерних классах. Пример:\n\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def speak(self):\n        pass"
  },
  {
    q: "Как работают итераторы и генераторы с точки зрения внутреннего устройства?",
    a: "Итераторы реализуют __iter__ и __next__, возвращают по одному элементу за раз. Генераторы — это функции с yield, которые возвращают объект generator. При вызове генератора он не выполняется сразу, а возвращает объект, который можно итерировать. Каждый вызов next() продолжает выполнение до следующего yield."
  },
  {
    q: "Что такое __dict__ и как он связан с атрибутами объекта?",
    a: "__dict__ — это словарь, в котором хранятся атрибуты объекта. Он позволяет динамически добавлять и изменять атрибуты. Однако использование __dict__ может быть медленным и неэффективным. Для оптимизации памяти иногда используется __slots__."
  },
  {
    q: "Как реализовать пользовательский контекстный менеджер через класс и через контекстlib?",
    a: "Через класс:\n\nclass MyContext:\n    def __enter__(self): return self\n    def __exit__(self, *args): pass\n\nЧерез контекстlib:\n\nfrom contextlib import contextmanager\n\n@contextmanager\ndef my_context():\n    print('Setup')\n    yield\n    print('Teardown')"
  },
  {
    q: "Как работают и что означают флаги -O, -OO, -m в командной строке Python?",
    a: "-O — включает оптимизацию (удаляет assert и __debug__).\n-OO — дополнительно удаляет строки документации.\n-m — запускает модуль как скрипт, например: python -m venv myenv."
  }
];