Нужно переписать все уроки по реакту оставляя формат таким же, что и был, но само содержимое конечно же заменить на тему уроков в реакте.
Курс реакт должен быть максимально полноценно прописана теория, а викторины и практические задания должны быть составленные строго по теме урока и не должны в себя включать темы которые мы не проходили.

В файл part1.jsx должна быть теория
В файле part2.jsx должна быть викторина
в файл part3.jsx должны быть практические задания

Все папки и файлы лежать в той же директории что и этот файл

Все папки и файлы уже созданы осталось их поменять

ОЧЕНЬ ВАЖНО УРОКИ НУЖНО СОЗДАВАТЬ В ФОРМАТЕ КОТОРЫЙ УЖЕ СОЗДАН В ПАПКЕ C:\Users\user\Desktop\freedev\my-app\src\data\courses\html\lesson8

# План изучения React

## МОДУЛЬ 1: Введение в React и основы работы

### Введение в React и первые шаги
Познакомимся с React, настроим окружение и создадим первые компоненты.

- [ ] 1 **Установка и настройка окружения**

  React требует Node.js и npm.
  Создайте проект с помощью:
  npx create-react-app my-app
  cd my-app
  npm start

  Структура проекта:
  - public/index.html — основной HTML
  - src/index.js — точка входа
  - src/App.js — главный компонент

  Приложение запускается на http://localhost:3000.

- [ ] 2 **JSX: HTML в JavaScript**

  JSX — это синтаксис, позволяющий писать HTML-подобный код в JavaScript.
  Пример:
  const element = <h1>Привет, React!</h1>;

  Особенности:
  - className вместо class
  - Стили через объект: style={{ color: 'red' }}
  - Выражения в фигурных скобках: {name}
  - Условия и циклы — через JS: &&, тернарный оператор, .map()

- [ ] 3 **Компоненты и пропсы**

  Компонент — это функция, возвращающая JSX.
  Пропсы (props) — способ передачи данных в компонент.

  Пример:
  function Button({ text, onClick }) {
    return <button onClick={onClick}>{text}</button>;
  }

  Пропсы нельзя менять — они read-only.
  Деструктуризация props делает код чище.

## МОДУЛЬ 2: Управление состоянием

### Состояние и управление данными
Научимся хранить и изменять данные внутри компонентов.

- [ ] 4 **Хук useState: управление состоянием**

  useState — хук для хранения изменяемых данных.
  import { useState } from 'react';

  Пример:
  const [count, setCount] = useState(0);

  setCount(value) — обновляет состояние и вызывает ререндер.
  Нельзя мутировать напрямую: count++ — ошибка.

  Используется для: счётчиков, форм, переключателей.

- [ ] 5 **Управляемые формы**

  Управляемые компоненты — когда значение input управляется React.
  Пример:
  <input value={name} onChange={(e) => setName(e.target.value)} />

  Все поля формы синхронизируются со state.
  Поддержка: input, textarea, select, checkbox.

- [ ] 6 **Работа со списками и ключи**

  Чтобы отобразить массив, используйте .map():
  {items.map(item => <li key={item.id}>{item.text}</li>)}

  Ключи (key) помогают React отслеживать изменения.
  Лучше использовать уникальный id, а не индекс.
  Без ключей — предупреждения и ошибки производительности.

## МОДУЛЬ 3: Эффекты и работа с API

### Побочные эффекты и внешние данные
Научимся работать с API, таймерами и другими эффектами.

- [ ] 7 **Хук useEffect: побочные эффекты**

  useEffect — хук для выполнения побочных эффектов.
  import { useEffect } from 'react';

  Пример:
  useEffect(() => {
    document.title = 'Страница загружена';
  }, []);

  Массив зависимостей:
  - [] — запускается один раз (как componentDidMount)
  - [count] — при изменении count
  - без массива — при каждом ререндере

  Можно возвращать функцию очистки (например, для таймеров).

- [ ] 8 **Работа с API и fetch**

  Получение данных с сервера:
  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users  ')
      .then(res => res.json())
      .then(data => setUsers(data));
  }, []);

  Важно обрабатывать:
  - Загрузку (loading)
  - Ошибки (error)
  - Пустые данные

  Не забывайте про очистку при размонтировании.

- [ ] 9 **Условный рендеринг и индикаторы**

  Показывайте разный контент в зависимости от состояния:
  - {loading && <p>Загрузка...</p>}
  - {error && <p>Ошибка: {error}</p>}
  - {!data.length ? <p>Нет данных</p> : <List items={data} />}

  Также можно использовать if/else или переменные.

## МОДУЛЬ 4: Продвинутые концепции

### Контекст, рефы и оптимизация
Глубже погружаемся в архитектуру React.

- [ ] 10 **Хук useContext: глобальное состояние**

  useContext позволяет избежать "пропс-дрейлинга".
  Создайте контекст:
  const ThemeContext = React.createContext();

  Оберните приложение в Provider:
  <ThemeContext.Provider value="dark">

  Используйте в компоненте: const theme = useContext(ThemeContext);

- [ ] 11 **Хук useReducer: сложное состояние**

  useReducer — альтернатива useState для сложной логики.
  Принцип: action → reducer → новое состояние.

  Пример:
  const [state, dispatch] = useReducer(reducer, initialState);

  Подходит для: форм, корзин, многошаговых процессов.

- [ ] 12 **Хук useRef: доступ к DOM и сохранение значений**

  useRef возвращает изменяемый объект с .current.
  Используется для:
  - Доступа к DOM-элементам: const inputRef = useRef()
    <input ref={inputRef} />
  - Сохранения значений между ререндерами (не вызывает обновления)
  - Хранения таймеров, интервалов

  Отличается от state: не вызывает ререндер.

## МОДУЛЬ 5: Повторное использование и производительность

### Кастомные хуки и оптимизация
Пишем переиспользуемый код и ускоряем приложение.

- [ ] 13 **Кастомные хуки**

  Кастомный хук — это функция, начинающаяся с "use".
  Пример: useFetch, useLocalStorage.

  Принцип: вынос логики из компонентов.
  Пример:
  function useLocalStorage(key, initialValue) {
    const [value, setValue] = useState(() => {
      return JSON.parse(localStorage.getItem(key)) || initialValue;
    });
    useEffect(() => {
      localStorage.setItem(key, JSON.stringify(value));
    }, [key, value]);
    return [value, setValue];
  }

- [ ]  14 **Композиция компонентов**

  Передача JSX через props с помощью {children}.
  Пример:
  <Modal><p>Это содержимое</p></Modal>

  Также можно использовать render-пропсы или композицию через props.

  Помогает делать компоненты гибкими: модальные окна, карточки, лейауты.

- [ ] 15 **Оптимизация производительности**

  React.memo — мемоизация компонента (не перерисовывает, если пропсы не изменились).
  useMemo — кэширует вычисления: const expensive = useMemo(() => calc(a, b), [a, b])
  useCallback — кэширует функции, чтобы не создавать заново

  Используйте, когда есть тяжёлые вычисления или частые ререндеры.

## МОДУЛЬ 6: Маршрутизация и проект

### Маршрутизация и итоговый проект
Создадим полноценное приложение с несколькими страницами.

- [ ] 16 **React Router: навигация по страницам**

  Установка: npm install react-router-dom

  Основные компоненты:
  - <BrowserRouter>
  - <Routes> и <Route path="/" element={<Home />} />
  - <Link to="/">Навигация без перезагрузки

  Динамические маршруты: /user/:id
  Доступ к параметрам: useParams()

- [ ] 17 **Формы: валидация и управление**

  Управление несколькими полями через объект:
  const [form, setForm] = useState({ name: '', email: '' })

  Валидация:
  - При вводе: onBlur, onChange
  - Показ ошибок: {errors.email && <span>Неверный email</span>}

  Можно использовать библиотеки (Formik, React Hook Form), но сначала — ванильный способ.

- [ ] 18 **Мини-проект: блог или магазин**

  Создайте приложение:
  - Список элементов (статьи, товары)
  - Детальная страница (по id)
  - Форма добавления
  - Поиск или фильтрация
  - Тема (через контекст)

  Используйте: компоненты, state, эффекты, роутинг, API.

- [ ] 19 **Деплой приложения**

  Подготовка: npm run build
  Статические файлы — в папке build/

  Деплой на:
  - Vercel (рекомендуется)
  - Netlify
  - GitHub Pages

  Просто загрузите папку build или подключите репозиторий.

## МОДУЛЬ 7: Что дальше?

### Что изучать дальше
План развития после базового React.

- [ ] 20 **TypeScript с React**

  TypeScript добавляет типизацию в React.
  Пример:
  interface Props {
    name: string;
    age?: number;
  }

  function User({ name, age }: Props) { ... }

  Помогает избегать ошибок и улучшает автодополнение.

- [ ] 21 **Популярные библиотеки**

  - Zustand / Redux Toolkit — управление состоянием
  - React Query — работа с API и кэширование
  - Tailwind CSS / Material UI — стилизация
  - Formik / React Hook Form — формы
  - Jest / React Testing Library — тестирование

- [ ] 22 **Архитектура и best practices**

  Как организовать проект:
  - Папки: components/, pages/, hooks/, services/, utils/
  - Именование: CamelCase для файлов, PascalCase для компонентов
  - Кастомные хуки для повторяющейся логики
  - Разделение ответственности

  Читайте документацию React, смотрите примеры из сообщества.

- [ ] 23 **Портфолио и следующие шаги**

  Добавьте проекты в GitHub.
  Напишите README с описанием, скриншотами, ссылкой на деплой.
  Готовьтесь к собеседованиям:
  - Объясните, как работает useState
  - Расскажите про виртуальный DOM
  - Продемонстрируйте свои проекты

  Главное — продолжайте практиковаться.
