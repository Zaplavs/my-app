export const reactPlan = [
  // МОДУЛЬ 1: Введение в React и основы работы
  {
    id: 'module-1',
    title: 'Введение в React и первые шаги',
    description: 'Познакомимся с React, настроим окружение и создадим первые компоненты.',
    lessons: [
      {
        id: 1,
        title: 'Установка и настройка окружения',
        content: `
          React требует Node.js и npm.
          Создайте проект с помощью:
          npx create-react-app my-app
          cd my-app
          npm start

          Структура проекта:
          - public/index.html — основной HTML
          - src/index.js — точка входа
          - src/App.js — главный компонент

          Приложение запускается на http://localhost:3000.
        `,
        task: 'Создайте новый React-проект, запустите его и измените текст в App.js.'
      },
      {
        id: 2,
        title: 'JSX: HTML в JavaScript',
        content: `
          JSX — это синтаксис, позволяющий писать HTML-подобный код в JavaScript.
          Пример:
          const element = <h1>Привет, React!</h1>;

          Особенности:
          - className вместо class
          - Стили через объект: style={{ color: 'red' }}
          - Выражения в фигурных скобках: {name}
          - Условия и циклы — через JS: &&, тернарный оператор, .map()
        `,
        task: 'Создайте элемент с динамическим именем, используя { } и .map() для списка.'
      },
      {
        id: 3,
        title: 'Компоненты и пропсы',
        content: `
          Компонент — это функция, возвращающая JSX.
          Пропсы (props) — способ передачи данных в компонент.

          Пример:
          function Button({ text, onClick }) {
            return <button onClick={onClick}>{text}</button>;
          }

          Пропсы нельзя менять — они read-only.
          Деструктуризация props делает код чище.
        `,
        task: 'Создайте компоненты Card, Header и Button. Передайте в них данные через props.'
      }
    ]
  },

  // МОДУЛЬ 2: Управление состоянием
  {
    id: 'module-2',
    title: 'Состояние и управление данными',
    description: 'Научимся хранить и изменять данные внутри компонентов.',
    lessons: [
      {
        id: 4,
        title: 'Хук useState: управление состоянием',
        content: `
          useState — хук для хранения изменяемых данных.
          import { useState } from 'react';

          Пример:
          const [count, setCount] = useState(0);

          setCount(value) — обновляет состояние и вызывает ререндер.
          Нельзя мутировать напрямую: count++ — ошибка.

          Используется для: счётчиков, форм, переключателей.
        `,
        task: 'Создайте счётчик с кнопками + и –. Отображайте текущее значение.'
      },
      {
        id: 5,
        title: 'Управляемые формы',
        content: `
          Управляемые компоненты — когда значение input управляется React.
          Пример:
          <input value={name} onChange={(e) => setName(e.target.value)} />

          Все поля формы синхронизируются со state.
          Поддержка: input, textarea, select, checkbox.
        `,
        task: 'Создайте форму с полями: имя, email, сообщение. Сохраняйте значения в state.'
      },
      {
        id: 6,
        title: 'Работа со списками и ключи',
        content: `
          Чтобы отобразить массив, используйте .map():
          {items.map(item => <li key={item.id}>{item.text}</li>)}

          Ключи (key) помогают React отслеживать изменения.
          Лучше использовать уникальный id, а не индекс.
          Без ключей — предупреждения и ошибки производительности.
        `,
        task: 'Создайте список задач (To-Do). Добавьте возможность добавлять и удалять элементы.'
      }
    ]
  },

  // МОДУЛЬ 3: Эффекты и работа с API
  {
    id: 'module-3',
    title: 'Побочные эффекты и внешние данные',
    description: 'Научимся работать с API, таймерами и другими эффектами.',
    lessons: [
      {
        id: 7,
        title: 'Хук useEffect: побочные эффекты',
        content: `
          useEffect — хук для выполнения побочных эффектов.
          import { useEffect } from 'react';

          Пример:
          useEffect(() => {
            document.title = 'Страница загружена';
          }, []);

          Массив зависимостей:
          - [] — запускается один раз (как componentDidMount)
          - [count] — при изменении count
          - без массива — при каждом ререндере

          Можно возвращать функцию очистки (например, для таймеров).
        `,
        task: 'Измените title страницы при загрузке. Добавьте таймер, который обновляет время каждую секунду.'
      },
      {
        id: 8,
        title: 'Работа с API и fetch',
        content: `
          Получение данных с сервера:
          useEffect(() => {
            fetch('https://jsonplaceholder.typicode.com/users')
              .then(res => res.json())
              .then(data => setUsers(data));
          }, []);

          Важно обрабатывать:
          - Загрузку (loading)
          - Ошибки (error)
          - Пустые данные

          Не забывайте про очистку при размонтировании.
        `,
        task: 'Загрузите список пользователей с JSONPlaceholder. Отобразите их имена.'
      },
      {
        id: 9,
        title: 'Условный рендеринг и индикаторы',
        content: `
          Показывайте разный контент в зависимости от состояния:
          - {loading && <p>Загрузка...</p>}
          - {error && <p>Ошибка: {error}</p>}
          - {!data.length ? <p>Нет данных</p> : <List items={data} />}

          Также можно использовать if/else или переменные.
        `,
        task: 'Добавьте спиннер при загрузке и сообщение об ошибке при сбое запроса.'
      }
    ]
  },

  // МОДУЛЬ 4: Продвинутые концепции
  {
    id: 'module-4',
    title: 'Контекст, рефы и оптимизация',
    description: 'Глубже погружаемся в архитектуру React.',
    lessons: [
      {
        id: 10,
        title: 'Хук useContext: глобальное состояние',
        content: `
          useContext позволяет избежать "пропс-дрейлинга".
          Создайте контекст:
          const ThemeContext = React.createContext();

          Оберните приложение в Provider:
          <ThemeContext.Provider value="dark">

          Используйте в компоненте: const theme = useContext(ThemeContext);
        `,
        task: 'Создайте тему (light/dark). Переключайте её и применяйте цвета через контекст.'
      },
      {
        id: 11,
        title: 'Хук useReducer: сложное состояние',
        content: `
          useReducer — альтернатива useState для сложной логики.
          Принцип: action → reducer → новое состояние.

          Пример:
          const [state, dispatch] = useReducer(reducer, initialState);

          Подходит для: форм, корзин, многошаговых процессов.
        `,
        task: 'Создайте корзину с товарами. Управляйте добавлением и удалением через useReducer.'
      },
      {
        id: 12,
        title: 'Хук useRef: доступ к DOM и сохранение значений',
        content: `
          useRef возвращает изменяемый объект с .current.
          Используется для:
          - Доступа к DOM-элементам: const inputRef = useRef()
            <input ref={inputRef} />
          - Сохранения значений между ререндерами (не вызывает обновления)
          - Хранения таймеров, интервалов

          Отличается от state: не вызывает ререндер.
        `,
        task: 'Сделайте так, чтобы при клике фокус устанавливался на input. Используйте useRef.'
      }
    ]
  },

  // МОДУЛЬ 5: Повторное использование и производительность
  {
    id: 'module-5',
    title: 'Кастомные хуки и оптимизация',
    description: 'Пишем переиспользуемый код и ускоряем приложение.',
    lessons: [
      {
        id: 13,
        title: 'Кастомные хуки',
        content: `
          Кастомный хук — это функция, начинающаяся с "use".
          Пример: useFetch, useLocalStorage.

          Принцип: вынос логики из компонентов.
          Пример:
          function useLocalStorage(key, initialValue) {
            const [value, setValue] = useState(() => {
              return JSON.parse(localStorage.getItem(key)) || initialValue;
            });
            useEffect(() => {
              localStorage.setItem(key, JSON.stringify(value));
            }, [key, value]);
            return [value, setValue];
          }
        `,
        task: 'Создайте хук useLocalStorage и используйте его для сохранения имени пользователя.'
      },
      {
        id: 14,
        title: 'Композиция компонентов',
        content: `
          Передача JSX через props с помощью {children}.
          Пример:
          <Modal><p>Это содержимое</p></Modal>

          Также можно использовать render-пропсы или композицию через props.

          Помогает делать компоненты гибкими: модальные окна, карточки, лейауты.
        `,
        task: 'Создайте компонент Card, который принимает заголовок и {children}. Используйте его в нескольких местах.'
      },
      {
        id: 15,
        title: 'Оптимизация производительности',
        content: `
          React.memo — мемоизация компонента (не перерисовывает, если пропсы не изменились).
          useMemo — кэширует вычисления: const expensive = useMemo(() => calc(a, b), [a, b])
          useCallback — кэширует функции, чтобы не создавать заново

          Используйте, когда есть тяжёлые вычисления или частые ререндеры.
        `,
        task: 'Оберните компонент в React.memo. Добавьте useMemo для фильтрации списка.'
      }
    ]
  },

  // МОДУЛЬ 6: Маршрутизация и проект
  {
    id: 'module-6',
    title: 'Маршрутизация и итоговый проект',
    description: 'Создадим полноценное приложение с несколькими страницами.',
    lessons: [
      {
        id: 16,
        title: 'React Router: навигация по страницам',
        content: `
          Установка: npm install react-router-dom

          Основные компоненты:
          - <BrowserRouter>
          - <Routes> и <Route path="/" element={<Home />} />
          - <Link to="/">Навигация без перезагрузки

          Динамические маршруты: /user/:id
          Доступ к параметрам: useParams()
        `,
        task: 'Создайте приложение с тремя страницами: Home, About, User. Добавьте навигацию.'
      },
      {
        id: 17,
        title: 'Формы: валидация и управление',
        content: `
          Управление несколькими полями через объект:
          const [form, setForm] = useState({ name: '', email: '' })

          Валидация:
          - При вводе: onBlur, onChange
          - Показ ошибок: {errors.email && <span>Неверный email</span>}

          Можно использовать библиотеки (Formik, React Hook Form), но сначала — ванильный способ.
        `,
        task: 'Добавьте валидацию формы: проверка email, обязательные поля.'
      },
      {
        id: 18,
        title: 'Мини-проект: блог или магазин',
        content: `
          Создайте приложение:
          - Список элементов (статьи, товары)
          - Детальная страница (по id)
          - Форма добавления
          - Поиск или фильтрация
          - Тема (через контекст)

          Используйте: компоненты, state, эффекты, роутинг, API.
        `,
        task: 'Разработайте мини-приложение (например, блог). Реализуйте основные экраны и навигацию.'
      },
      {
        id: 19,
        title: 'Деплой приложения',
        content: `
          Подготовка: npm run build
          Статические файлы — в папке build/

          Деплой на:
          - Vercel (рекомендуется)
          - Netlify
          - GitHub Pages

          Просто загрузите папку build или подключите репозиторий.
        `,
        task: 'Задеплойте своё приложение на Vercel или Netlify. Проверьте работоспособность.'
      }
    ]
  },

  // МОДУЛЬ 7: Что дальше?
  {
    id: 'module-7',
    title: 'Что изучать дальше',
    description: 'План развития после базового React.',
    lessons: [
      {
        id: 20,
        title: 'TypeScript с React',
        content: `
          TypeScript добавляет типизацию в React.
          Пример:
          interface Props {
            name: string;
            age?: number;
          }

          function User({ name, age }: Props) { ... }

          Помогает избегать ошибок и улучшает автодополнение.
        `,
        task: 'Перепишите один компонент на TypeScript (создайте проект через create-react-app --template typescript).'
      },
      {
        id: 21,
        title: 'Популярные библиотеки',
        content: `
          - Zustand / Redux Toolkit — управление состоянием
          - React Query — работа с API и кэширование
          - Tailwind CSS / Material UI — стилизация
          - Formik / React Hook Form — формы
          - Jest / React Testing Library — тестирование
        `,
        task: 'Установите и попробуйте одну из библиотек (например, React Query или Tailwind CSS).'
      },
      {
        id: 22,
        title: 'Архитектура и best practices',
        content: `
          Как организовать проект:
          - Папки: components/, pages/, hooks/, services/, utils/
          - Именование: CamelCase для файлов, PascalCase для компонентов
          - Кастомные хуки для повторяющейся логики
          - Разделение ответственности

          Читайте документацию React, смотрите примеры из сообщества.
        `,
        task: 'Переосмыслите структуру своего проекта. Разделите на папки и добавьте комментарии.'
      },
      {
        id: 23,
        title: 'Портфолио и следующие шаги',
        content: `
          Добавьте проекты в GitHub.
          Напишите README с описанием, скриншотами, ссылкой на деплой.
          Готовьтесь к собеседованиям:
          - Объясните, как работает useState
          - Расскажите про виртуальный DOM
          - Продемонстрируйте свои проекты

          Главное — продолжайте практиковаться.
        `,
        task: 'Добавьте 2–3 React-проекта в GitHub. Подготовьте короткое описание каждого.'
      }
    ]
  }
];