export default [
  {
    question: "Как работает механизм JIT-компиляции в .NET и чем отличается от AOT?",
    options: [
      "JIT компилирует IL в нативный код во время выполнения, AOT - до запуска",
      "JIT медленнее",
      "AOT не поддерживается",
      "JIT работает только с .NET Framework"
    ],
    answer: "JIT компилирует IL в нативный код во время выполнения, AOT - до запуска",
    explanation: {
      correct: "JIT (Just-In-Time) компилятор преобразует IL-код в нативный машинный код во время выполнения, что позволяет оптимизировать под конкретную платформу, в то время как AOT (Ahead-Of-Time) компилирует заранее",
      incorrect: "Неверно, JIT компилирует код во время выполнения, что позволяет применять контекстуальные оптимизации, в отличие от AOT, который компилирует до запуска"
    }
  },
  {
    question: "Что такое Tiered Compilation в .NET и как он работает?",
    options: [
      "Поэтапная компиляция: сначала быстро, затем с оптимизациями",
      "Компиляция в несколько потоков",
      "Разделение кода по уровням",
      "Оптимизация для многоядерных систем"
    ],
    answer: "Поэтапная компиляция: сначала быстро, затем с оптимизациями",
    explanation: {
      correct: "Tiered Compilation позволяет сначала быстро скомпилировать код с минимальными оптимизациями, а затем, при необходимости, перекомпилировать с агрессивными оптимизациями для часто используемых методов",
      incorrect: "Неверно, tiered compilation - это когда JIT сначала создает быстрый код, а затем, при повторных вызовах, генерирует высокооптимизированный код"
    }
  },
  {
    question: "Как работает garbage collector в .NET и какие у него поколения?",
    options: [
      "Трехпоколенческий GC: 0, 1, 2 с разными стратегиями сборки",
      "Однопоколенческий",
      "Двухпоколенческий",
      "Без поколений"
    ],
    answer: "Трехпоколенческий GC: 0, 1, 2 с разными стратегиями сборки",
    explanation: {
      correct: "GC в .NET использует трехпоколенческую модель: Generation 0 для новых объектов, Generation 1 для промежуточных, Generation 2 для долгоживущих, с разными частотами и стратегиями сборки",
      incorrect: "Неверно, .NET GC использует трехпоколенческую модель для эффективного управления памятью с учетом поведения объектов"
    }
  },
  {
    question: "Что такое escape analysis в контексте .NET?",
    options: [
      "Анализ, определяющий, может ли объект быть выделен на стеке",
      "Анализ исключений",
      "Оптимизация строк",
      "Проверка границ"
    ],
    answer: "Анализ, определяющий, может ли объект быть выделен на стеке",
    explanation: {
      correct: "Escape analysis определяет, может ли объект 'побежать' за пределы метода, что позволяет JIT-компилятору размещать его на стеке вместо кучи, уменьшая нагрузку на GC",
      incorrect: "Неверно, escape analysis - это оптимизация, при которой JIT определяет, может ли объект быть безопасно размещен на стеке"
    }
  },
  {
    question: "Как работает механизм inlining в JIT-компиляторе .NET?",
    options: [
      "Вставка тела метода в место вызова для уменьшения накладных расходов",
      "Удаление методов",
      "Замена на интерфейсы",
      "Оптимизация вызовов"
    ],
    answer: "Вставка тела метода в место вызова для уменьшения накладных расходов",
    explanation: {
      correct: "Inlining - это ключевая оптимизация, при которой JIT вставляет код метода непосредственно в место вызова, устраняя накладные расходы на вызов и позволяя дальнейшие оптимизации",
      incorrect: "Неверно, inlining - это когда JIT-компилятор вставляет тело метода в место вызова, устраняя накладные расходы"
    }
  },
  {
    question: "Что такое value type optimization и как она работает?",
    options: [
      "Оптимизация, позволяющая размещать структуры на стеке или инлайнить их в другие объекты",
      "Оптимизация для значений",
      "Метод оптимизации памяти",
      "Система типов"
    ],
    answer: "Оптимизация, позволяющая размещать структуры на стеке или инлайнить их в другие объекты",
    explanation: {
      correct: "Value type optimization позволяет размещать структуры на стеке, инлайнить их поля в классы и избегать boxing, что значительно повышает производительность",
      incorrect: "Неверно, оптимизации для value types включают размещение на стеке, инлайниг и избежание boxing"
    }
  },
  {
    question: "Как работает механизм virtual method dispatch в .NET?",
    options: [
      "Через таблицу виртуальных методов (vtable) для динамического разрешения вызовов",
      "Через интерфейсы",
      "С помощью reflection",
      "На основе имени метода"
    ],
    answer: "Через таблицу виртуальных методов (vtable) для динамического разрешения вызовов",
    explanation: {
      correct: "Вызовы виртуальных методов разрешаются через vtable - таблицу указателей на реализации методов, что позволяет динамически определять, какая реализация должна быть вызвана",
      incorrect: "Неверно, virtual method dispatch в .NET реализуется через vtable, что обеспечивает эффективное динамическое разрешение вызовов"
    }
  },
  {
    question: "Что такое speculative optimization в JIT-компиляторе?",
    options: [
      "Генерация оптимизированного кода на основе предположений с возможностью отката",
      "Оптимизация только проверенного кода",
      "Работа только с примитивами",
      "Без предположений"
    ],
    answer: "Генерация оптимизированного кода на основе предположений с возможностью отката",
    explanation: {
      correct: "JIT делает предположения (о типах, отсутствии переопределения и т.д.) и генерирует высокооптимизированный код, который может быть деоптимизирован при нарушении предположений",
      incorrect: "Неверно, speculative optimization - это когда JIT-компилятор делает предположения и генерирует оптимизированный код, который может быть деоптимизирован при их нарушении"
    }
  },
  {
    question: "Как работает механизм deoptimization в .NET?",
    options: [
      "Возврат к менее оптимизированному коду при нарушении предположений JIT",
      "Удаление оптимизаций",
      "Остановка JIT",
      "Перезапуск приложения"
    ],
    answer: "Возврат к менее оптимизированному коду при нарушении предположений JIT",
    explanation: {
      correct: "Deoptimization происходит, когда предположения JIT (например, о типах или отсутствии переопределения) нарушаются, и система возвращается к менее оптимизированному, но корректному коду",
      incorrect: "Неверно, deoptimization - это процесс, при котором JIT-компилятор откатывает оптимизированный код к менее оптимизированному при нарушении предположений"
    }
  },
  {
    question: "Что такое SIMD и как он используется в .NET?",
    options: [
      "Использование векторных инструкций для параллельной обработки данных",
      "Система многопоточности",
      "Метод оптимизации",
      "Система ввода-вывода"
    ],
    answer: "Использование векторных инструкций для параллельной обработки данных",
    explanation: {
      correct: "SIMD (Single Instruction, Multiple Data) позволяет выполнять одну операцию над несколькими данными одновременно, что значительно ускоряет вычисления, поддерживается через System.Numerics.Vector",
      incorrect: "Неверно, SIMD - это использование векторных процессорных инструкций для параллельной обработки данных, что поддерживается в .NET"
    }
  },
  {
    question: "Как работает механизм tail call optimization в .NET?",
    options: [
      "Позволяет избежать роста стека при хвостовой рекурсии",
      "Оптимизирует все рекурсивные вызовы",
      "Не поддерживается",
      "Работает только с методами классов"
    ],
    answer: "Позволяет избежать роста стека при хвостовой рекурсии",
    explanation: {
      correct: "Tail call optimization позволяет переиспользовать кадр стека при хвостовой рекурсии, избегая переполнения стека, хотя поддержка в .NET не гарантирована",
      incorrect: "Неверно, TCO может применяться к хвостовым вызовам, позволяя избежать роста стека, хотя в .NET это не гарантировано"
    }
  },
  {
    question: "Что такое async state machine и как она генерируется?",
    options: [
      "Автоматически создаваемая машина состояний для реализации async/await",
      "Состояние асинхронного потока",
      "Метод многопоточности",
      "Система управления"
    ],
    answer: "Автоматически создаваемая машина состояний для реализации async/await",
    explanation: {
      correct: "Компилятор C# преобразует async методы в класс state machine, который управляет состоянием асинхронной операции и продолжением выполнения после await",
      incorrect: "Неверно, async state machine - это код, генерируемый компилятором для реализации механизма async/await"
    }
  },
  {
    question: "Как работает механизм covariance и contravariance в generic-ах на уровне CLR?",
    options: [
      "Поддерживается только для делегатов и интерфейсов с out/in модификаторами",
      "Работает для всех generic-ов",
      "Не поддерживается",
      "Только для классов"
    ],
    answer: "Поддерживается только для делегатов и интерфейсов с out/in модификаторами",
    explanation: {
      correct: "CLR поддерживает вариантность только для делегатов и интерфейсов, помеченных модификаторами out (covariance) и in (contravariance)",
      incorrect: "Неверно, вариантность в .NET поддерживается только для делегатов и интерфейсов с соответствующими модификаторами"
    }
  },
  {
    question: "Что такое constrained call в IL?",
    options: [
      "Вызов метода на обобщенном параметре с возможностью избежать boxing",
      "Ограниченный вызов",
      "Метод оптимизации",
      "Система вызовов"
    ],
    answer: "Вызов метода на обобщенном параметре с возможностью избежать boxing",
    explanation: {
      correct: "Constrained call позволяет вызывать виртуальные методы на обобщенных параметрах, избегая boxing для value types, что критически важно для производительности generic-кода",
      incorrect: "Неверно, constrained call - это IL-инструкция, позволяющая эффективно вызывать методы на T, избегая boxing для структур"
    }
  },
  {
    question: "Как работает механизм inlining для generic-методов?",
    options: [
      "Может инлайниться для конкретных специализаций",
      "Никогда не инлайнится",
      "Только для ссылочных типов",
      "Только для примитивов"
    ],
    answer: "Может инлайниться для конкретных специализаций",
    explanation: {
      correct: "Generic-методы могут быть инлайнены для конкретных специализаций, когда JIT имеет достаточно информации о типах и поведении метода",
      incorrect: "Неверно, JIT может инлайнить generic-методы для конкретных типов, когда это безопасно и эффективно"
    }
  },
  {
    question: "Что такое ready-to-run (R2R) compilation?",
    options: [
      "Предварительная компиляция IL в нативный код для ускорения запуска",
      "Готовый к запуску код",
      "Метод оптимизации",
      "Система сборки"
    ],
    answer: "Предварительная компиляция IL в нативный код для ускорения запуска",
    explanation: {
      correct: "Ready-to-Run компиляция предварительно компилирует IL в нативный код, что уменьшает время запуска приложения за счет уменьшения работы JIT во время выполнения",
      incorrect: "Неверно, R2R - это AOT-компиляция, которая ускоряет запуск приложения за счет предварительной компиляции"
    }
  },
  {
    question: "Как работает механизм value type stack allocation?",
    options: [
      "Размещение структур на стеке вместо кучи",
      "Выделение памяти",
      "Оптимизация памяти",
      "Система управления"
    ],
    answer: "Размещение структур на стеке вместо кучи",
    explanation: {
      correct: "Структуры по умолчанию размещаются на стеке, что избегает нагрузки на GC и ускоряет доступ, в отличие от классов, которые размещаются в куче",
      incorrect: "Неверно, value types размещаются на стеке, что обеспечивает высокую производительность и уменьшает нагрузку на сборщик мусора"
    }
  },
  {
    question: "Что такое method dispatch cache в .NET?",
    options: [
      "Кэш для ускорения разрешения виртуальных вызовов",
      "Кэш методов",
      "Оптимизация вызовов",
      "Система доступа"
    ],
    answer: "Кэш для ускорения разрешения виртуальных вызовов",
    explanation: {
      correct: "Method dispatch cache кэширует результаты разрешения виртуальных вызовов, что ускоряет повторные вызовы, особенно для часто используемых методов",
      incorrect: "Неверно, method dispatch cache - это оптимизация, ускоряющая разрешение виртуальных вызовов путем кэширования результатов"
    }
  },
  {
    question: "Как работает механизм async method return caching?",
    options: [
      "Кэширование уже завершенных Task для избежания аллокаций",
      "Кэширование методов",
      "Оптимизация памяти",
      "Система возврата"
    ],
    answer: "Кэширование уже завершенных Task для избежания аллокаций",
    explanation: {
      correct: ".NET кэширует часто используемые уже завершенные Task (например, Task.CompletedTask), что позволяет избежать повторных аллокаций и уменьшить нагрузку на GC",
      incorrect: "Неверно, .NET использует пул для часто используемых завершенных Task, что уменьшает аллокации и нагрузку на GC"
    }
  },
  {
    question: "Что такое Span<T> и как он влияет на производительность?",
    options: [
      "Безопасная обертка для работы с памятью без аллокаций",
      "Новый тип данных",
      "Метод оптимизации",
      "Система памяти"
    ],
    answer: "Безопасная обертка для работы с памятью без аллокаций",
    explanation: {
      correct: "Span<T> позволяет безопасно работать с блоками памяти (массивы, stackalloc, unmanaged memory) без аллокаций и с проверкой границ, что критично для производительности",
      incorrect: "Неверно, Span<T> - это ref struct, позволяющий эффективно работать с памятью без аллокаций и с безопасностью доступа"
    }
  },
  {
    question: "Как работает механизм inlining для виртуальных методов?",
    options: [
      "Может инлайниться при наличии информации о конкретном типе",
      "Никогда не инлайнится",
      "Только для sealed классов",
      "Только для статических методов"
    ],
    answer: "Может инлайниться при наличии информации о конкретном типе",
    explanation: {
      correct: "JIT может инлайнить виртуальные вызовы, когда знает конкретный тип объекта (например, после проверки типа), что позволяет получить преимущества inlining и виртуального полиморфизма",
      incorrect: "Неверно, JIT может инлайнить виртуальные методы, когда имеет достаточно информации о типе объекта"
    }
  },
  {
    question: "Что такое generic specialization в .NET?",
    options: [
      "Создание специализированных версий generic-кода для конкретных типов",
      "Специализация типов",
      "Метод оптимизации",
      "Система наследования"
    ],
    answer: "Создание специализированных версий generic-кода для конкретных типов",
    explanation: {
      correct: "CLR создает отдельные специализации generic-типов для значимых типов и общую для всех ссылочных типов, что позволяет оптимизировать производительность",
      incorrect: "Неверно, generic specialization - это когда CLR создает специализированные версии кода для разных типов, особенно для value types"
    }
  },
  {
    question: "Как работает механизм escape analysis для ref struct?",
    options: [
      "Гарантирует, что ref struct не 'побегает' за пределы стека",
      "Анализ исключений",
      "Оптимизация памяти",
      "Система контроля"
    ],
    answer: "Гарантирует, что ref struct не 'побегает' за пределы стека",
    explanation: {
      correct: "Компилятор и CLR анализируют, может ли ref struct 'побежать' за пределы метода, что гарантирует его размещение только на стеке и безопасность памяти",
      incorrect: "Неверно, escape analysis для ref struct гарантирует, что они остаются в пределах стека, обеспечивая безопасность"
    }
  },
  {
    question: "Что такое tail recursion и как она оптимизируется?",
    options: [
      "Рекурсия, где рекурсивный вызов является последним, может быть оптимизирована в цикл",
      "Хвостовая оптимизация",
      "Метод оптимизации",
      "Система рекурсии"
    ],
    answer: "Рекурсия, где рекурсивный вызов является последним, может быть оптимизирована в цикл",
    explanation: {
      correct: "Tail recursion - это когда рекурсивный вызов является последней операцией в методе, что позволяет оптимизировать его в цикл, избегая роста стека",
      incorrect: "Неверно, tail recursion может быть оптимизирована в цикл, что предотвращает переполнение стека"
    }
  },
  {
    question: "Как работает механизм inlining для delegate вызовов?",
    options: [
      "Может инлайниться при наличии информации о целевом методе",
      "Никогда не инлайнится",
      "Только для статических методов",
      "Только для виртуальных"
    ],
    answer: "Может инлайниться при наличии информации о целевом методе",
    explanation: {
      correct: "JIT может инлайнить вызовы через делегаты, когда знает целевой метод, что позволяет устранить накладные расходы на вызов делегата",
      incorrect: "Неверно, при наличии информации о целевом методе JIT может инлайнить вызовы через делегаты"
    }
  },
  {
    question: "Что такое method dispatch polymorphism в .NET?",
    options: [
      "Динамическое разрешение вызовов методов на основе типа объекта",
      "Многообразие методов",
      "Метод оптимизации",
      "Система вызовов"
    ],
    answer: "Динамическое разрешение вызовов методов на основе типа объекта",
    explanation: {
      correct: "Method dispatch polymorphism позволяет вызывать правильную реализацию метода на основе фактического типа объекта во время выполнения, через механизм vtable",
      incorrect: "Неверно, method dispatch polymorphism - это динамическое разрешение вызовов виртуальных методов на основе типа объекта"
    }
  },
  {
    question: "Как работает механизм async method state machine caching?",
    options: [
      "Повторное использование state machine для одинаковых async методов",
      "Кэширование методов",
      "Оптимизация памяти",
      "Система управления"
    ],
    answer: "Повторное использование state machine для одинаковых async методов",
    explanation: {
      correct: "Компилятор может оптимизировать создание state machine, особенно для методов без захвата переменных, что уменьшает аллокации",
      incorrect: "Неверно, компилятор может применять оптимизации для повторного использования state machine в определенных сценариях"
    }
  },
  {
    question: "Что такое generic constraint optimization?",
    options: [
      "Оптимизация вызовов методов с учетом ограничений generic-параметров",
      "Ограничение типов",
      "Метод оптимизации",
      "Система наследования"
    ],
    answer: "Оптимизация вызовов методов с учетом ограничений generic-параметров",
    explanation: {
      correct: "Ограничения generic-параметров позволяют JIT делать предположения о доступных методах и свойствах, что позволяет применять более агрессивные оптимизации",
      incorrect: "Неверно, generic constraints позволяют компилятору и JIT применять более эффективные оптимизации на основе известных свойств типов"
    }
  },
  {
    question: "Как работает механизм inlining для extension methods?",
    options: [
      "Может инлайниться как обычные статические методы",
      "Никогда не инлайнится",
      "Только для встроенных методов",
      "Только для классов"
    ],
    answer: "Может инлайниться как обычные статические методы",
    explanation: {
      correct: "Extension methods компилируются в статические методы и могут быть инлайнены JIT-компилятором, как и любые другие статические методы",
      incorrect: "Неверно, extension methods - это просто синтаксический сахар над статическими методами, которые могут быть инлайнены"
    }
  },
  {
    question: "Что такое async method exception handling optimization?",
    options: [
      "Оптимизация создания объектов исключений в асинхронных методах",
      "Обработка исключений",
      "Метод оптимизации",
      "Система безопасности"
    ],
    answer: "Оптимизация создания объектов исключений в асинхронных методах",
    explanation: {
      correct: "Компилятор и runtime применяют оптимизации для уменьшения накладных расходов на обработку исключений в async методах, включая кэширование состояний",
      incorrect: "Неверно, существуют специальные оптимизации для обработки исключений в асинхронных методах, уменьшающие накладные расходы"
    }
  }
];