export default [
  {
    question: "Как работает двухэтапный поиск (two-phase lookup) в шаблонах C++?",
    options: [
      "Разделяет поиск на зависимые и независимые от шаблона имена",
      "Ищет сначала в базовом классе, потом в производном",
      "Ищет сначала в текущем пространстве имен",
      "Проверяет синтаксис в два этапа"
    ],
    answer: "Разделяет поиск на зависимые и независимые от шаблона имена",
    explanation: {
      correct: "Two-phase lookup разделяет имена в шаблонах на зависимые (зависящие от параметров шаблона) и независимые. Независимые имена проверяются при определении шаблона, зависимые - при инстанцировании",
      incorrect: "Неверно, two-phase lookup - это когда компилятор разделяет имена в шаблонах на зависимые и независимые от параметров шаблона для правильного разрешения"
    }
  },
  {
    question: "Что такое ODR (One Definition Rule) и как он применяется?",
    options: [
      "Каждый объект или функция должна иметь ровно одно определение в программе",
      "Одно определение на файл",
      "Правило для классов",
      "Метод оптимизации"
    ],
    answer: "Каждый объект или функция должна иметь ровно одно определение в программе",
    explanation: {
      correct: "ODR требует, чтобы любая переменная, функция, класс или шаблон имели ровно одно определение в программе, хотя могут иметь несколько объявлений",
      incorrect: "Неверно, ODR - это фундаментальное правило C++, требующее ровно одного определения для каждого объекта или функции во всей программе"
    }
  },
  {
    question: "Как работает механизм overload resolution в C++?",
    options: [
      "Выбирает наилучшее соответствие среди перегруженных функций",
      "Случайный выбор",
      "Выбирает первую подходящую",
      "Выбирает самую быструю"
    ],
    answer: "Выбирает наилучшее соответствие среди перегруженных функций",
    explanation: {
      correct: "Overload resolution анализирует все перегруженные функции и выбирает наилучшее соответствие на основе аргументов вызова, учитывая точность преобразований",
      incorrect: "Неверно, overload resolution - это сложный процесс, который выбирает наилучшее соответствие среди перегруженных функций на основе аргументов"
    }
  },
  {
    question: "Что такое SFINAE и как он используется в enable_if?",
    options: [
      "Используется для условной компиляции шаблонов на основе свойств типов",
      "Метод оптимизации",
      "Система типов",
      "Ошибка компиляции"
    ],
    answer: "Используется для условной компиляции шаблонов на основе свойств типов",
    explanation: {
      correct: "SFINAE с enable_if позволяет включать или исключать шаблоны из рассмотрения на основе условий, что используется для реализации concepts до C++20",
      incorrect: "Неверно, SFINAE с enable_if - это мощный механизм для условной компиляции шаблонов в зависимости от свойств типов"
    }
  },
  {
    question: "Как работает механизм ADL (Argument-Dependent Lookup) с шаблонами?",
    options: [
      "Ищет функции в пространствах имен типов аргументов, включая инстанцированные шаблоны",
      "Игнорирует шаблоны",
      "Ищет только в глобальном пространстве",
      "Работает только с обычными функциями"
    ],
    answer: "Ищет функции в пространствах имен типов аргументов, включая инстанцированные шаблоны",
    explanation: {
      correct: "ADL работает и с шаблонами, позволяя находить функции в пространствах имен, связанных с типами аргументов, включая типы, полученные из шаблонов",
      incorrect: "Неверно, ADL корректно работает с шаблонами, что позволяет, например, использовать операторы для типов из шаблонов"
    }
  },
  {
    question: "Что такое expression SFINAE и как он отличается от обычного SFINAE?",
    options: [
      "Позволяет использовать любые выражения в условиях SFINAE",
      "Более строгая проверка",
      "Работает только с типами",
      "Не поддерживается"
    ],
    answer: "Позволяет использовать любые выражения в условиях SFINAE",
    explanation: {
      correct: "Expression SFINAE (введено в C++11) позволяет использовать любые выражения в условиях SFINAE, а не только типы, что значительно расширяет возможности метапрограммирования",
      incorrect: "Неверно, expression SFINAE позволяет использовать произвольные выражения в условиях, что делает метапрограммирование более гибким"
    }
  },
  {
    question: "Как работает механизм виртуального наследования?",
    options: [
      "Обеспечивает единственность базового класса в иерархии наследования",
      "Создает виртуальные таблицы",
      "Оптимизирует память",
      "Позволяет множественное наследование"
    ],
    answer: "Обеспечивает единственность базового класса в иерархии наследования",
    explanation: {
      correct: "Виртуальное наследование гарантирует, что в иерархии наследования будет только один экземпляр виртуального базового класса, даже при множественном наследовании",
      incorrect: "Неверно, виртуальное наследование решает проблему 'алмазного наследования', обеспечивая единственность базового класса"
    }
  },
  {
    question: "Что такое strict aliasing rule и как она влияет на оптимизации?",
    options: [
      "Запрещает доступ к объекту через указатель несовместимого типа",
      "Правило для указателей",
      "Метод оптимизации",
      "Система типов"
    ],
    answer: "Запрещает доступ к объекту через указатель несовместимого типа",
    explanation: {
      correct: "Strict aliasing rule запрещает доступ к объекту через указатель типа, несовместимого с его фактическим типом, что позволяет компилятору применять агрессивные оптимизации",
      incorrect: "Неверно, strict aliasing rule - это правило, которое позволяет компилятору предполагать, что указатели разных типов не ссылаются на одну и ту же память"
    }
  },
  {
    question: "Как работает механизм elision of copy/move operations?",
    options: [
      "Компилятор может устранять промежуточные копирования даже при наличии побочных эффектов",
      "Всегда копирует объекты",
      "Удаляет все операции",
      "Работает только с POD-типами"
    ],
    answer: "Компилятор может устранять промежуточные копирования даже при наличии побочных эффектов",
    explanation: {
      correct: "Copy/move elision - это оптимизация, разрешенная стандартом, при которой компилятор может устранять вызовы конструкторов копирования/перемещения даже если они имеют побочные эффекты",
      incorrect: "Неверно, copy/move elision - это единственная оптимизация в C++, разрешенная стандартом даже при наличии побочных эффектов"
    }
  },
  {
    question: "Что такое pointer to member и как он работает?",
    options: [
      "Указывает на член класса, а не на конкретный объект",
      "Указатель на объект",
      "Специальный тип указателя",
      "Метод для наследования"
    ],
    answer: "Указывает на член класса, а не на конкретный объект",
    explanation: {
      correct: "Pointer to member указывает на член класса (поле или метод), а не на конкретный экземпляр, и требует объект для доступа к члену",
      incorrect: "Неверно, pointer to member - это уникальный механизм C++, позволяющий указывать на члены класса независимо от конкретного объекта"
    }
  },
  {
    question: "Как работает механизм overload resolution для операторов?",
    options: [
      "Учитывает как обычные функции, так и операторы, определенные в классах",
      "Только обычные функции",
      "Только операторы классов",
      "Случайный выбор"
    ],
    answer: "Учитывает как обычные функции, так и операторы, определенные в классах",
    explanation: {
      correct: "Overload resolution для операторов рассматривает как обычные функции-операторы, так и операторы, определенные как методы классов, и выбирает наилучшее соответствие",
      incorrect: "Неверно, overload resolution для операторов учитывает все возможные способы их определения и выбирает наилучшее соответствие"
    }
  },
  {
    question: "Что такое unevaluated context в C++?",
    options: [
      "Контекст, где выражения не вычисляются, но проверяются на корректность",
      "Ошибочный контекст",
      "Метод оптимизации",
      "Система проверки"
    ],
    answer: "Контекст, где выражения не вычисляются, но проверяются на корректность",
    explanation: {
      correct: "Unevaluated contexts (sizeof, noexcept, decltype, и т.д.) позволяют анализировать выражения без их выполнения, что используется в метапрограммировании",
      incorrect: "Неверно, unevaluated contexts - это когда выражение анализируется на корректность, но не выполняется, что позволяет безопасно проверять свойства типов"
    }
  },
  {
    question: "Как работает механизм виртуальных таблиц (vtable) на низком уровне?",
    options: [
      "Каждый объект содержит указатель на таблицу функций, позволяя динамическое разрешение вызовов",
      "Таблица для всех классов",
      "Система оптимизации",
      "Метод наследования"
    ],
    answer: "Каждый объект содержит указатель на таблицу функций, позволяя динамическое разрешение вызовов",
    explanation: {
      correct: "Объекты с виртуальными функциями содержат скрытое поле с указателем на vtable, которая содержит указатели на реализации виртуальных функций для данного типа",
      incorrect: "Неверно, vtable - это механизм, при котором каждый объект с виртуальными функциями имеет указатель на таблицу функций для динамического разрешения вызовов"
    }
  },
  {
    question: "Что такое template argument deduction и как она работает?",
    options: [
      "Автоматическое определение параметров шаблона из аргументов функции",
      "Дедукция типов",
      "Метод оптимизации",
      "Система типов"
    ],
    answer: "Автоматическое определение параметров шаблона из аргументов функции",
    explanation: {
      correct: "Template argument deduction позволяет компилятору автоматически определять параметры шаблона на основе аргументов, переданных в шаблонную функцию",
      incorrect: "Неверно, template argument deduction - это когда компилятор выводит параметры шаблона из типов аргументов вызова"
    }
  },
  {
    question: "Как работает механизм reference collapsing?",
    options: [
      "Правила преобразования ссылок на ссылки в одну ссылку",
      "Сворачивание указателей",
      "Оптимизация памяти",
      "Метод наследования"
    ],
    answer: "Правила преобразования ссылок на ссылки в одну ссылку",
    explanation: {
      correct: "Reference collapsing rules (T& &, T& &&, T&& &, T&& &&) определяют, как сочетания ссылок преобразуются в одну ссылку, что критически важно для perfect forwarding",
      incorrect: "Неверно, reference collapsing - это набор правил, определяющих результат сочетания ссылок, особенно важных для perfect forwarding"
    }
  },
  {
    question: "Что такое CRTP (Curiously Recurring Template Pattern) и как он используется для статического полиморфизма?",
    options: [
      "Позволяет реализовать полиморфизм на этапе компиляции без виртуальных функций",
      "Метод оптимизации",
      "Система наследования",
      "Техника многопоточности"
    ],
    answer: "Позволяет реализовать полиморфизм на этапе компиляции без виртуальных функций",
    explanation: {
      correct: "CRTP позволяет реализовать статический полиморфизм, где вызовы методов разрешаются на этапе компиляции, что устраняет накладные расходы на виртуальные вызовы",
      incorrect: "Неверно, CRTP - это паттерн, позволяющий реализовать полиморфизм без виртуальных функций и vtable, с разрешением на этапе компиляции"
    }
  },
  {
    question: "Как работает механизм ADL с перегруженными операторами?",
    options: [
      "Позволяет находить операторы в пространствах имен аргументов",
      "Игнорирует операторы",
      "Работает только с глобальными операторами",
      "Только с методами классов"
    ],
    answer: "Позволяет находить операторы в пространствах имен аргументов",
    explanation: {
      correct: "ADL позволяет находить перегруженные операторы не только в глобальном пространстве, но и в пространствах имен, связанных с типами аргументов",
      incorrect: "Неверно, ADL критически важен для работы операторов, позволяя находить их в пространствах имен аргументов"
    }
  },
  {
    question: "Что такое type erasure и как он реализуется в std::function?",
    concepts: [
      "Скрытие конкретного типа за единым интерфейсом",
      "Удаление типов",
      "Метод оптимизации",
      "Система наследования"
    ],
    answer: "Скрытие конкретного типа за единым интерфейсом",
    explanation: {
      correct: "Type erasure позволяет работать с объектами разных типов через единый интерфейс, скрывая их конкретный тип, как в std::function, который может хранить любой вызываемый объект",
      incorrect: "Неверно, type erasure - это техника, при которой конкретный тип скрывается за абстрактным интерфейсом, позволяя работать с разными типами единообразно"
    }
  },
  {
    question: "Как работает механизм overload resolution с шаблонами?",
    options: [
      "Сначала выбирает нешаблонные функции, затем шаблоны с наилучшей специализацией",
      "Только шаблоны",
      "Только нешаблонные",
      "Случайный выбор"
    ],
    answer: "Сначала выбирает нешаблонные функции, затем шаблоны с наилучшей специализацией",
    explanation: {
      correct: "Overload resolution сначала рассматривает нешаблонные функции, затем шаблонные, выбирая наиболее специализированный шаблон при равенстве по качеству соответствия",
      incorrect: "Неверно, overload resolution учитывает и шаблонные, и нешаблонные функции, с предпочтением более специализированным шаблонам"
    }
  },
  {
    question: "Что такое SFINAE и как он используется в enable_if?",
    options: [
      "Позволяет условно включать шаблоны на основе свойств типов",
      "Метод оптимизации",
      "Система типов",
      "Ошибка компиляции"
    ],
    answer: "Позволяет условно включать шаблоны на основе свойств типов",
    explanation: {
      correct: "SFINAE с enable_if позволяет включать или исключать шаблоны из рассмотрения на основе условий, что используется для реализации concepts до C++20",
      incorrect: "Неверно, SFINAE с enable_if - это мощный механизм для условной компиляции шаблонов в зависимости от свойств типов"
    }
  },
  {
    question: "Как работает механизм виртуального деструктора на уровне vtable?",
    options: [
      "Добавляет запись в vtable для правильного разрушения объекта",
      "Удаляет объект",
      "Оптимизирует память",
      "Не влияет на vtable"
    ],
    answer: "Добавляет запись в vtable для правильного разрушения объекта",
    explanation: {
      correct: "Виртуальный деструктор добавляет запись в vtable, что позволяет вызывать правильный деструктор при удалении через базовый указатель",
      incorrect: "Неверно, виртуальный деструктор добавляет запись в vtable, что обеспечивает правильное разрушение объектов при полиморфном удалении"
    }
  },
  {
    question: "Что такое perfect forwarding и как он реализуется?",
    options: [
      "Передача аргументов с сохранением их категорий через std::forward",
      "Идеальная передача",
      "Оптимизация вызовов",
      "Метод копирования"
    ],
    answer: "Передача аргументов с сохранением их категорий через std::forward",
    explanation: {
      correct: "Perfect forwarding реализуется через шаблонные параметры и std::forward, позволяя передавать аргументы точно так же, как они были получены",
      incorrect: "Неверно, perfect forwarding - это когда аргументы передаются дальше с сохранением информации о том, были ли они lvalue или rvalue"
    }
  },
  {
    question: "Как работает механизм ADL с функциями-друзьями (friend functions)?",
    options: [
      "Позволяет находить дружественные функции через ADL",
      "Игнорирует дружественные функции",
      "Работает только с обычными функциями",
      "Только с методами классов"
    ],
    answer: "Позволяет находить дружественные функции через ADL",
    explanation: {
      correct: "Дружественные функции, определенные внутри класса, становятся доступными через ADL, что позволяет им быть найденными при вызове с аргументами этого класса",
      incorrect: "Неверно, дружественные функции, определенные внутри класса, могут быть найдены через ADL, что важно для операторов"
    }
  },
  {
    question: "Что такое expression templates и как они используются?",
    options: [
      "Техника для отсрочки вычислений и оптимизации выражений",
      "Шаблоны выражений",
      "Метод оптимизации",
      "Система вычислений"
    ],
    answer: "Техника для отсрочки вычислений и оптимизации выражений",
    explanation: {
      correct: "Expression templates позволяют создавать промежуточные объекты, представляющие выражения, что позволяет применять оптимизации вроде loop fusion и избегать временных объектов",
      incorrect: "Неверно, expression templates - это мощная техника метапрограммирования, позволяющая оптимизировать вычисления, откладывая их выполнение"
    }
  },
  {
    question: "Как работает механизм overload resolution с конвертирующими конструкторами?",
    options: [
      "Учитывает неявные преобразования через конструкторы",
      "Игнорирует конструкторы",
      "Только явные преобразования",
      "Не работает с конструкторами"
    ],
    answer: "Учитывает неявные преобразования через конструкторы",
    explanation: {
      correct: "Overload resolution учитывает неявные преобразования, включая те, которые выполняются через конвертирующие конструкторы, при выборе наилучшего соответствия",
      incorrect: "Неверно, overload resolution учитывает все возможные преобразования, включая те, что выполняются через конвертирующие конструкторы"
    }
  },
  {
    question: "Что такое strict aliasing и как обойти его ограничения?",
    options: [
      "Использовать std::memcpy или std::bit_cast для безопасного преобразования",
      "Игнорировать правила",
      "Использовать union",
      "Применять оптимизации"
    ],
    answer: "Использовать std::memcpy или std::bit_cast для безопасного преобразования",
    explanation: {
      correct: "Для безопасного reinterpretation данных следует использовать std::memcpy (в C++17 и ранее) или std::bit_cast (в C++20), а не указатели на разные типы",
      incorrect: "Неверно, нарушение strict aliasing rule приводит к undefined behavior; безопасные способы включают std::memcpy и std::bit_cast"
    }
  },
  {
    question: "Как работает механизм виртуального наследования на уровне памяти?",
    options: [
      "Использует указатели на виртуальные базы для обеспечения единственности",
      "Копирует базовый класс",
      "Оптимизирует память",
      "Не влияет на структуру"
    ],
    answer: "Использует указатели на виртуальные базы для обеспечения единственности",
    explanation: {
      correct: "Виртуальное наследование использует дополнительные указатели на виртуальные базовые классы, что позволяет обеспечить единственность базового класса в иерархии",
      incorrect: "Неверно, виртуальное наследование использует механизм с указателями для обеспечения единственности базового класса при множественном наследовании"
    }
  },
  {
    question: "Что такое CRTP и как он используется для оптимизации?",
    options: [
      "Позволяет устранить накладные расходы на виртуальные вызовы",
      "Метод оптимизации",
      "Система наследования",
      "Техника многопоточности"
    ],
    answer: "Позволяет устранить накладные расходы на виртуальные вызовы",
    explanation: {
      correct: "CRTP позволяет реализовать полиморфизм без виртуальных функций, что устраняет накладные расходы на vtable и косвенные вызовы",
      incorrect: "Неверно, основное преимущество CRTP - это статический полиморфизм без накладных расходов на виртуальные вызовы"
    }
  },
  {
    question: "Как работает механизм ADL с операторами приведения типов?",
    options: [
      "Позволяет находить пользовательские операторы приведения",
      "Игнорирует операторы",
      "Работает только с встроенными типами",
      "Только с методами классов"
    ],
    answer: "Позволяет находить пользовательские операторы приведения",
    explanation: {
      correct: "ADL позволяет находить пользовательские операторы приведения типов в пространствах имен аргументов, что важно для корректной работы с пользовательскими типами",
      incorrect: "Неверно, ADL работает и с операторами приведения типов, позволяя находить их в соответствующих пространствах имен"
    }
  }
];