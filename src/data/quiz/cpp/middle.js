export default [
  {
    question: "Что такое RAII и как он работает в C++?",
    options: [
      "Идиома, привязывающая управление ресурсами к времени жизни объекта",
      "Метод оптимизации памяти",
      "Система сборки мусора",
      "Техника многопоточности"
    ],
    answer: "Идиома, привязывающая управление ресурсами к времени жизни объекта",
    explanation: {
      correct: "RAII (Resource Acquisition Is Initialization) - это идиома C++, при которой захват ресурса происходит при инициализации объекта, а освобождение - при его уничтожении",
      incorrect: "Неверно, RAII - это фундаментальная идиома C++, при которой управление ресурсами привязано к времени жизни объекта"
    }
  },
  {
    question: "Чем отличается std::vector от std::array?",
    options: [
      "std::vector имеет динамический размер, std::array - фиксированный",
      "std::array быстрее",
      "std::vector требует new",
      "std::array не поддерживает итераторы"
    ],
    answer: "std::vector имеет динамический размер, std::array - фиксированный",
    explanation: {
      correct: "std::vector может изменять свой размер во время выполнения, в то время как std::array имеет фиксированный размер, известный на этапе компиляции",
      incorrect: "Неверно, основное различие в изменяемости размера: vector динамический, array фиксированный"
    }
  },
  {
    question: "Что такое move semantics в C++11?",
    options: [
      "Передача владения ресурсами без копирования",
      "Перемещение объектов в памяти",
      "Оптимизация циклов",
      "Метод копирования"
    ],
    answer: "Передача владения ресурсами без копирования",
    explanation: {
      correct: "Move semantics позволяют 'перемещать' ресурсы из одного объекта в другой, избегая costly копирования, особенно полезно для временных объектов",
      incorrect: "Неверно, move semantics - это механизм передачи владения ресурсами (например, памятью) от одного объекта к другому без копирования"
    }
  },
  {
    question: "Что такое smart pointers и какие виды существуют?",
    options: [
      "Умные указатели: unique_ptr, shared_ptr, weak_ptr",
      "Автоматические указатели",
      "Новые типы данных",
      "Методы для работы с памятью"
    ],
    answer: "Умные указатели: unique_ptr, shared_ptr, weak_ptr",
    explanation: {
      correct: "Smart pointers - это классы-обертки над обычными указателями, обеспечивающие автоматическое управление памятью: unique_ptr (уникальное владение), shared_ptr (разделяемое владение), weak_ptr (слабая ссылка)",
      incorrect: "Неверно, smart pointers - это умные указатели, которые автоматически управляют временем жизни объектов"
    }
  },
  {
    question: "Что такое copy elision и RVO?",
    options: [
      "Оптимизации, устраняющие ненужные копирования объектов",
      "Методы копирования",
      "Ошибки памяти",
      "Техники многопоточности"
    ],
    answer: "Оптимизации, устраняющие ненужные копирования объектов",
    explanation: {
      correct: "Copy elision и Return Value Optimization (RVO) - это оптимизации компилятора, которые устраняют промежуточные копирования объектов при возврате из функций",
      incorrect: "Неверно, copy elision и RVO - это оптимизации, которые позволяют избежать ненужных копирований объектов"
    }
  },
  {
    question: "Чем отличается deep copy от shallow copy?",
    options: [
      "Deep copy копирует все вложенные объекты, shallow copy - только ссылки",
      "Deep copy медленнее",
      "Shallow copy не работает с указателями",
      "Deep copy требует больше памяти"
    ],
    answer: "Deep copy копирует все вложенные объекты, shallow copy - только ссылки",
    explanation: {
      correct: "При deep copy создаются копии всех вложенных объектов, при shallow copy копируются только указатели на объекты",
      incorrect: "Неверно, основное различие в глубине копирования: deep копирует все объекты рекурсивно, shallow - только ссылки"
    }
  },
  {
    question: "Что такое виртуальные функции и как они реализуются?",
    options: [
      "Функции, разрешение которых происходит во время выполнения через vtable",
      "Функции с виртуальной памятью",
      "Оптимизированные функции",
      "Функции для виртуальных машин"
    ],
    answer: "Функции, разрешение которых происходит во время выполнения через vtable",
    explanation: {
      correct: "Виртуальные функции реализуются через таблицу виртуальных методов (vtable), что позволяет динамически определять, какая реализация должна быть вызвана",
      incorrect: "Неверно, виртуальные функции используют механизм vtable для динамического разрешения вызовов во время выполнения"
    }
  },
  {
    question: "Зачем деструктору класса с виртуальными функциями быть виртуальным?",
    options: [
      "Чтобы при удалении через базовый указатель вызывался правильный деструктор",
      "Для производительности",
      "Чтобы избежать утечек памяти",
      "Для совместимости"
    ],
    answer: "Чтобы при удалении через базовый указатель вызывался правильный деструктор",
    explanation: {
      correct: "Виртуальный деструктор гарантирует, что при удалении объекта производного класса через указатель на базовый класс будет вызван правильный деструктор",
      incorrect: "Неверно, виртуальный деструктор необходим для корректного разрушения объектов при использовании полиморфизма"
    }
  },
  {
    question: "Что такое const correctness в C++?",
    options: [
      "Использование const для указания неизменяемости",
      "Правильное использование констант",
      "Метод оптимизации",
      "Система типов"
    ],
    answer: "Использование const для указания неизменяемости",
    explanation: {
      correct: "Const correctness - это практика использования ключевого слова const для указания, что объекты, параметры, методы или указатели не должны изменяться",
      incorrect: "Неверно, const correctness - это важный принцип C++, обеспечивающий безопасность и документирующий намерения разработчика"
    }
  },
  {
    question: "Чем отличается std::string от C-строк?",
    options: [
      "std::string управляет памятью автоматически и безопаснее",
      "std::string быстрее",
      "C-строки современнее",
      "std::string не поддерживает Unicode"
    ],
    answer: "std::string управляет памятью автоматически и безопаснее",
    explanation: {
      correct: "std::string является классом, который автоматически управляет памятью, предоставляет безопасные методы и исключает многие ошибки, характерные для C-строк",
      incorrect: "Неверно, std::string безопаснее и удобнее, так как автоматически управляет памятью и предоставляет методы для работы со строками"
    }
  },
  {
    question: "Что такое iterators в C++ и какие категории существуют?",
    options: [
      "Объекты для обхода контейнеров: input, output, forward, bidirectional, random access",
      "Индексы массивов",
      "Методы для циклов",
      "Указатели на элементы"
    ],
    answer: "Объекты для обхода контейнеров: input, output, forward, bidirectional, random access",
    explanation: {
      correct: "Итераторы - это объекты, которые позволяют обходить элементы контейнеров, существуют различные категории с разными возможностями доступа",
      incorrect: "Неверно, итераторы - это абстракция для обхода контейнеров, с различными категориями, предоставляющими разные операции"
    }
  },
  {
    question: "Что такое STL и из каких компонентов он состоит?",
    options: [
      "Стандартная библиотека шаблонов: контейнеры, алгоритмы, итераторы",
      "Система типов",
      "Библиотека для строк",
      "Шаблоны для классов"
    ],
    answer: "Стандартная библиотека шаблонов: контейнеры, алгоритмы, итераторы",
    explanation: {
      correct: "STL состоит из контейнеров (vector, list, map), алгоритмов (sort, find) и итераторов, которые связывают первые два компонента",
      incorrect: "Неверно, STL - это мощная библиотека, состоящая из контейнеров, алгоритмов и итераторов"
    }
  },
  {
    question: "Что такое template specialization?",
    options: [
      "Предоставление конкретной реализации шаблона для определенного типа",
      "Создание специальных шаблонов",
      "Оптимизация шаблонов",
      "Наследование шаблонов"
    ],
    answer: "Предоставление конкретной реализации шаблона для определенного типа",
    explanation: {
      correct: "Template specialization позволяет предоставить специальную реализацию шаблона для конкретного типа, отличную от общей реализации",
      incorrect: "Неверно, template specialization - это когда для определенного типа предоставляется специальная реализация шаблона"
    }
  },
  {
    question: "Что такое SFINAE (Substitution Failure Is Not An Error)?",
    options: [
      "Принцип, при котором ошибка подстановки в шаблоне не является фатальной",
      "Ошибка компиляции",
      "Метод оптимизации",
      "Система типов"
    ],
    answer: "Принцип, при котором ошибка подстановки в шаблоне не является фатальной",
    explanation: {
      correct: "SFINAE - это принцип C++, при котором если подстановка аргументов шаблона приводит к ошибке, это не считается ошибкой компиляции, а просто исключает эту специализацию из рассмотрения",
      incorrect: "Неверно, SFINAE - это важный механизм, позволяющий реализовывать условную компиляцию на основе свойств типов"
    }
  },
  {
    question: "Что такое lambda expressions в C++11?",
    options: [
      "Анонимные функции, которые могут захватывать переменные из окружающей области",
      "Новые типы данных",
      "Методы для многопоточности",
      "Оптимизация кода"
    ],
    answer: "Анонимные функции, которые могут захватывать переменные из окружающей области",
    explanation: {
      correct: "Lambda expressions позволяют определять анонимные функции прямо в месте использования, с возможностью захвата переменных из окружающей области видимости",
      incorrect: "Неверно, лямбды - это компактный способ создания анонимных функций с захватом переменных"
    }
  },
  {
    question: "Чем отличается std::unique_ptr от std::shared_ptr?",
    options: [
      "unique_ptr обеспечивает уникальное владение, shared_ptr - разделяемое",
      "shared_ptr быстрее",
      "unique_ptr требует new",
      "shared_ptr не потокобезопасен"
    ],
    answer: "unique_ptr обеспечивает уникальное владение, shared_ptr - разделяемое",
    explanation: {
      correct: "std::unique_ptr обеспечивает эксклюзивное владение объектом, в то время как std::shared_ptr использует подсчет ссылок для разделяемого владения",
      incorrect: "Неверно, основное различие в модели владения: unique_ptr - уникальное, shared_ptr - разделяемое"
    }
  },
  {
    question: "Что такое rvalue references и для чего они нужны?",
    options: [
      "Ссылки на временные объекты, необходимые для move semantics",
      "Ссылки на правые значения",
      "Оптимизация памяти",
      "Новые типы данных"
    ],
    answer: "Ссылки на временные объекты, необходимые для move semantics",
    explanation: {
      correct: "Rvalue references (обозначаются как &&) позволяют отличать временные объекты от обычных, что необходимо для реализации move semantics",
      incorrect: "Неверно, rvalue references - это ключевой механизм для реализации move semantics, позволяющий эффективно передавать ресурсы"
    }
  },
  {
    question: "Что такое perfect forwarding?",
    options: [
      "Передача аргументов с сохранением их категорий (lvalue/rvalue)",
      "Идеальная передача",
      "Оптимизация вызовов",
      "Метод копирования"
    ],
    answer: "Передача аргументов с сохранением их категорий (lvalue/rvalue)",
    explanation: {
      correct: "Perfect forwarding позволяет передавать аргументы в функцию точно так же, как они были получены, сохраняя информацию о том, были ли они lvalue или rvalue",
      incorrect: "Неверно, perfect forwarding - это когда аргументы передаются дальше без потери информации о их категории"
    }
  },
  {
    question: "Что такое CRTP (Curiously Recurring Template Pattern)?",
    options: [
      "Шаблон, где класс наследует от шаблонизированной версии самого себя",
      "Рекурсивные шаблоны",
      "Метод наследования",
      "Оптимизация производительности"
    ],
    answer: "Шаблон, где класс наследует от шаблонизированной версии самого себя",
    explanation: {
      correct: "CRTP - это паттерн, при котором класс наследует от шаблонного класса с самим собой в качестве аргумента, что позволяет реализовать статический полиморфизм",
      incorrect: "Неверно, CRTP - это когда класс наследует от шаблонного базового класса с самим собой в качестве параметра"
    }
  },
  {
    question: "Что такое placement new?",
    options: [
      "Создание объекта в уже выделенной памяти",
      "Новый тип размещения",
      "Метод оптимизации",
      "Специальный оператор"
    ],
    answer: "Создание объекта в уже выделенной памяти",
    explanation: {
      correct: "Placement new позволяет создавать объект в уже выделенной области памяти, что полезно для реализации своих аллокаторов или работы с разделяемой памятью",
      incorrect: "Неверно, placement new - это возможность создавать объекты в указанной области памяти"
    }
  },
  {
    question: "Что такое noexcept specifier?",
    options: [
      "Указывает, может ли функция генерировать исключения",
      "Запрещает исключения",
      "Метод обработки ошибок",
      "Система исключений"
    ],
    answer: "Указывает, может ли функция генерировать исключения",
    explanation: {
      correct: "noexcept specifier указывает, может ли функция генерировать исключения, что позволяет компилятору применять дополнительные оптимизации",
      incorrect: "Неверно, noexcept помогает компилятору оптимизировать код и принимать решения о безопасности операций"
    }
  },
  {
    question: "Что такое type traits в C++?",
    options: [
      "Шаблоны для получения информации о типах во время компиляции",
      "Новые типы данных",
      "Методы для типизации",
      "Система наследования"
    ],
    answer: "Шаблоны для получения информации о типах во время компиляции",
    explanation: {
      correct: "Type traits - это шаблоны, которые предоставляют информацию о свойствах типов (например, является ли тип целочисленным, имеет ли деструктор и т.д.) во время компиляции",
      incorrect: "Неверно, type traits - это метафункции, предоставляющие информацию о типах на этапе компиляции"
    }
  },
  {
    question: "Что такое SBO (Small Buffer Optimization)?",
    options: [
      "Оптимизация, при которой малые объекты хранятся непосредственно в самом объекте",
      "Буферизация строк",
      "Метод оптимизации памяти",
      "Система хранения"
    ],
    answer: "Оптимизация, при которой малые объекты хранятся непосредственно в самом объекте",
    explanation: {
      correct: "SBO позволяет хранить небольшие объекты (например, короткие строки) непосредственно в памяти самого объекта, избегая выделения памяти в куче",
      incorrect: "Неверно, SBO - это когда объекты небольшого размера хранятся встроенно, что ускоряет работу и уменьшает фрагментацию"
    }
  },
  {
    question: "Что такое rule of five в C++?",
    options: [
      "Если нужно определить один из пяти специальных методов, вероятно, нужно определить все",
      "Правила для пяти типов",
      "Методы наследования",
      "Правила оптимизации"
    ],
    answer: "Если нужно определить один из пяти специальных методов, вероятно, нужно определить все",
    explanation: {
      correct: "Rule of five гласит, что если класс требует пользовательского деструктора, копирующего конструктора, копирующего оператора присваивания, перемещающего конструктора или перемещающего оператора присваивания, то, вероятно, требуются все пять",
      incorrect: "Неверно, rule of five - это принцип, согласно которому определение одного из специальных методов часто требует определения всех"
    }
  },
  {
    question: "Что такое ADL (Argument-Dependent Lookup)?",
    options: [
      "Поиск функций в пространствах имен аргументов",
      "Автоматический поиск",
      "Метод наследования",
      "Система типов"
    ],
    answer: "Поиск функций в пространствах имен аргументов",
    explanation: {
      correct: "ADL позволяет находить функции в пространствах имен, связанных с типами аргументов, что объясняет, почему работают операторы вроде operator<< для cout",
      incorrect: "Неверно, ADL - это когда компилятор ищет функции не только в текущей области, но и в пространствах имен аргументов"
    }
  },
  {
    question: "Что такое std::move и что он делает?",
    options: [
      "Преобразует lvalue в rvalue reference для использования move semantics",
      "Перемещает объект в памяти",
      "Копирует объект",
      "Удаляет объект"
    ],
    answer: "Преобразует lvalue в rvalue reference для использования move semantics",
    explanation: {
      correct: "std::move не перемещает объект, а просто преобразует lvalue в rvalue reference, позволяя вызвать move-конструктор или move-оператор",
      incorrect: "Неверно, std::move - это просто cast к rvalue reference, который разрешает использование move-семантики"
    }
  },
  {
    question: "Что такое copy-and-swap idiom?",
    options: [
      "Паттерн для реализации оператора присваивания с гарантией безопасности исключений",
      "Метод копирования",
      "Оптимизация памяти",
      "Система обмена"
    ],
    answer: "Паттерн для реализации оператора присваивания с гарантией безопасности исключений",
    explanation: {
      correct: "Copy-and-swap идиома использует копирующий конструктор и swap для реализации оператора присваивания, обеспечивая strong exception safety",
      incorrect: "Неверно, copy-and-swap - это паттерн, обеспечивающий безопасность при исключениях при реализации оператора присваивания"
    }
  },
  {
    question: "Что такое std::forward и для чего он используется?",
    options: [
      "Perfect forwarding аргументов в шаблонных функциях",
      "Пересылка сообщений",
      "Оптимизация вызовов",
      "Метод передачи"
    ],
    answer: "Perfect forwarding аргументов в шаблонных функциях",
    explanation: {
      correct: "std::forward используется для perfect forwarding, позволяя передавать аргументы дальше с сохранением их категории (lvalue/rvalue)",
      incorrect: "Неверно, std::forward необходим для реализации perfect forwarding в шаблонных функциях"
    }
  },
  {
    question: "Что такое memory ordering в многопоточном контексте?",
    options: [
      "Определяет порядок выполнения операций с памятью между потоками",
      "Упорядочивание памяти",
      "Метод оптимизации",
      "Система синхронизации"
    ],
    answer: "Определяет порядок выполнения операций с памятью между потоками",
    explanation: {
      correct: "Memory ordering определяет, как операции с памятью становятся видимыми для других потоков, что критически важно для корректной работы многопоточных программ",
      incorrect: "Неверно, memory ordering - это спецификация, определяющая порядок видимости операций с памятью между потоками"
    }
  },
  {
    question: "Что такое std::async и как он работает?",
    options: [
      "Запускает функцию асинхронно и возвращает std::future",
      "Асинхронный вызов",
      "Метод многопоточности",
      "Система потоков"
    ],
    answer: "Запускает функцию асинхронно и возвращает std::future",
    explanation: {
      correct: "std::async позволяет запускать функцию асинхронно (возможно, в отдельном потоке) и возвращает объект std::future, через который можно получить результат",
      incorrect: "Неверно, std::async - это удобный способ запуска функций асинхронно с получением результата через future"
    }
  }
];