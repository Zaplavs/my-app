export default [
  {
    question: "Что происходит при вызове Function.prototype.call() с null в strict mode?",
    options: [
      "this устанавливается в глобальный объект",
      "this устанавливается в null",
      "Генерируется ошибка",
      "this устанавливается в window"
    ],
    answer: "this устанавливается в null",
    explanation: {
      correct: "В strict mode значение this не преобразуется в глобальный объект, поэтому при передаче null, this останется null",
      incorrect: "Неверно, в strict mode this не преобразуется в глобальный объект, в отличие от non-strict mode"
    }
  },
  {
    question: "Как работает механизм 'hoisting' с функциями, объявленными через Function Expression?",
    options: [
      "Функция полностью поднимается и инициализируется",
      "Только переменная поднимается, но остается undefined",
      "Функция не поднимается вообще",
      "Функция поднимается только в пределах блока"
    ],
    answer: "Только переменная поднимается, но остается undefined",
    explanation: {
      correct: "При объявлении функции через Function Expression, переменная поднимается, но присваивание происходит только в месте объявления",
      incorrect: "Неверно, Function Expression поднимает только переменную, но не инициализирует функцию до места объявления"
    }
  },
  {
    question: "Что такое 'observable' в контексте асинхронных паттернов JavaScript?",
    options: [
      "Объект, который может уведомлять подписчиков об изменениях",
      "Специальный тип промиса",
      "Метод для отслеживания производительности",
      "Декоратор для классов"
    ],
    answer: "Объект, который может уведомлять подписчиков об изменениях",
    explanation: {
      correct: "Observable - это паттерн, представляющий поток данных, который может уведомлять подписчиков о новых значениях, ошибки и завершении",
      incorrect: "Неверно, Observable - это реактивный паттерн для работы с асинхронными потоками данных, используемый в библиотеках вроде RxJS"
    }
  },
  {
    question: "Какой алгоритм используется в методе Array.prototype.sort() в современных движках JavaScript?",
    options: [
      "Quick Sort",
      "Merge Sort",
      "Timsort",
      "Bubble Sort"
    ],
    answer: "Timsort",
    explanation: {
      correct: "Современные движки JavaScript (V8, SpiderMonkey) используют Timsort - гибридный стабильный алгоритм сортировки, сочетающий merge sort и insertion sort",
      incorrect: "Неверно, современные движки используют Timsort, а не Quick Sort, из-за его стабильности и эффективности на частично отсортированных данных"
    }
  },
  {
    question: "Что такое 'speculative optimization' в JIT-компиляторах JavaScript?",
    options: [
      "Оптимизация на основе предположений о типах данных",
      "Оптимизация для мобильных устройств",
      "Специальная оптимизация для массивов",
      "Оптимизация при загрузке страницы"
    ],
    answer: "Оптимизация на основе предположений о типах данных",
    explanation: {
      correct: "JIT-компиляторы делают предположения о типах переменных и оптимизируют код, откатываясь при нарушении предположений (deoptimization)",
      incorrect: "Неверно, speculative optimization - это когда JIT делает предположения о типах и поведении кода для создания более эффективной машинной инструкции"
    }
  },
  {
    question: "Как работает 'hidden class' оптимизация в V8?",
    options: [
      "Создает скрытые классы для безопасности",
      "Группирует объекты с одинаковой структурой для оптимизации доступа к свойствам",
      "Скрывает внутренние свойства объектов",
      "Создает приватные классы"
    ],
    answer: "Группирует объекты с одинаковой структурой для оптимизации доступа к свойствам",
    explanation: {
      correct: "V8 создает 'скрытые классы' для объектов с одинаковой структурой, что позволяет оптимизировать доступ к свойствам через смещения в памяти",
      incorrect: "Неверно, hidden classes - это внутренняя оптимизация V8, где объекты с одинаковой структурой получают одинаковый класс для быстрого доступа к свойствам"
    }
  },
  {
    question: "Что такое 'callback hell' и как современные подходы решают эту проблему?",
    options: [
      "Сложная структура вложенных функций, решается через Promise и async/await",
      "Ошибка в callback функциях",
      "Проблема с производительностью",
      "Ошибки в обработке событий"
    ],
    answer: "Сложная структура вложенных функций, решается через Promise и async/await",
    explanation: {
      correct: "Callback hell - это глубокая вложенность callback-функций, которая усложняет чтение кода. Решается через промисы, async/await и другие асинхронные паттерны",
      incorrect: "Неверно, callback hell - это проблема читаемости из-за вложенных callback-функций, которая решается современными асинхронными подходами"
    }
  },
  {
    question: "Как работает 'event delegation' и в чем его преимущества?",
    options: [
      "Назначение обработчиков событий на родительские элементы для эффективности",
      "Создание кастомных событий",
      "Делегирование событий между окнами",
      "Автоматическая обработка событий"
    ],
    answer: "Назначение обработчиков событий на родительские элементы для эффективности",
    explanation: {
      correct: "Event delegation использует всплытие событий, позволяя обрабатывать события на родительском элементе, что эффективнее при работе с динамическим контентом",
      incorrect: "Неверно, event delegation - это паттерн, при котором обработчик назначается на родительский элемент для управления событиями дочерних элементов"
    }
  },
  {
    question: "Что такое 'memory leak' в JavaScript и как его избежать?",
    options: [
      "Утечка памяти из-за неправильного управления ссылками",
      "Ошибка в работе с массивами",
      "Проблема с сетевыми запросами",
      "Ошибка в обработке событий"
    ],
    answer: "Утечка памяти из-за неправильного управления ссылками",
    explanation: {
      correct: "Memory leak происходит, когда объекты остаются в памяти, хотя они больше не нужны, часто из-за неправильных ссылок, замыканий или обработчиков событий",
      incorrect: "Неверно, memory leak - это когда память не освобождается, хотя объекты больше не используются, что может привести к падению производительности"
    }
  },
  {
    question: "Как работает 'prototype chain' при вызове методов?",
    options: [
      "Поиск метода происходит от объекта к прототипу и далее по цепочке",
      "Методы вызываются только у самого объекта",
      "Поиск происходит в обратном порядке",
      "Методы кэшируются при первом вызове"
    ],
    answer: "Поиск метода происходит от объекта к прототипу и далее по цепочке",
    explanation: {
      correct: "JavaScript ищет метод сначала в самом объекте, затем в его прототипе, и так далее по цепочке прототипов до Object.prototype",
      incorrect: "Неверно, поиск метода происходит по прототипной цепочке от объекта к его прототипам"
    }
  },
  {
    question: "Что такое 'tail call optimization' и поддерживается ли она в JavaScript?",
    options: [
      "Оптимизация последнего вызова функции, поддерживается в strict mode по спецификации, но не во всех движках",
      "Оптимизация для массивов",
      "Оптимизация циклов",
      "Не поддерживается вообще"
    ],
    answer: "Оптимизация последнего вызова функции, поддерживается в strict mode по спецификации, но не во всех движках",
    explanation: {
      correct: "TCO позволяет избежать переполнения стека при рекурсии, если рекурсивный вызов является последней операцией. Поддерживается спецификацией ES6 в strict mode, но реализация зависит от движка",
      incorrect: "Неверно, TCO поддерживается спецификацией, но ее реализация в движках JavaScript неполная из-за сложностей с отладкой"
    }
  },
  {
    question: "Как работает 'caching' в методе Object.defineProperty() при использовании геттеров?",
    options: [
      "Значение вычисляется каждый раз при обращении",
      "Значение кэшируется после первого вычисления",
      "Кэширование зависит от движка",
      "Кэширование отключено по умолчанию"
    ],
    answer: "Значение вычисляется каждый раз при обращении",
    explanation: {
      correct: "Геттеры выполняются при каждом обращении к свойству, поэтому значение не кэшируется автоматически и вычисляется каждый раз",
      incorrect: "Неверно, геттеры выполняются при каждом доступе к свойству, поэтому для кэширования нужно реализовать его вручную"
    }
  },
  {
    question: "Что такое 'symbol' и в чем его основное применение?",
    options: [
      "Уникальный идентификатор, используемый для создания скрытых свойств объектов",
      "Специальный тип для работы с иконками",
      "Метод для шифрования",
      "Тип данных для математических операций"
    ],
    answer: "Уникальный идентификатор, используемый для создания скрытых свойств объектов",
    explanation: {
      correct: "Symbol - это примитивный тип, создающий уникальные идентификаторы, часто используемые для создания неитерируемых и невидимых свойств объектов",
      incorrect: "Неверно, Symbol создает уникальные значения, которые можно использовать как ключи свойств, обеспечивая их уникальность и скрытость"
    }
  },
  {
    question: "Как работает 'event loop' с микрозадачами и макрозадачами?",
    options: [
      "Выполняет все микрозадачи после каждой макрозадачи",
      "Выполняет макрозадачи первыми",
      "Очередь задач не имеет приоритета",
      "Микрозадачи выполняются только при ошибках"
    ],
    answer: "Выполняет все микрозадачи после каждой макрозадачи",
    explanation: {
      correct: "После выполнения каждой макрозадачи event loop выполняет все находящиеся в очереди микрозадачи, прежде чем перейти к следующей макрозадаче",
      incorrect: "Неверно, event loop имеет приоритет микрозадач: после каждой макрозадачи выполняются все микрозадачи из очереди"
    }
  },
  {
    question: "Что такое 'proxy' в JavaScript и для чего он используется?",
    options: [
      "Объект, который позволяет перехватывать и переопределять операции с другим объектом",
      "Серверный прокси",
      "Метод для работы с сетью",
      "Тип данных для промисов"
    ],
    answer: "Объект, который позволяет перехватывать и переопределять операции с другим объектом",
    explanation: {
      correct: "Proxy позволяет создавать ловушки для операций с объектом, такие как получение/установка свойств, вызов методов и другие операции",
      incorrect: "Неверно, Proxy - это мощный инструмент для перехвата операций с объектами, используемый для валидации, логирования, реактивности и других паттернов"
    }
  },
  {
    question: "Как работает 'circular reference' в контексте сборки мусора?",
    options: [
      "Современные сборщики мусора могут обрабатывать циклические ссылки",
      "Всегда приводит к утечке памяти",
      "Может быть обработан только вручную",
      "Запрещен в JavaScript"
    ],
    answer: "Современные сборщики мусора могут обрабатывать циклические ссылки",
    explanation: {
      correct: "Современные сборщики мусора используют алгоритмы типа mark-and-sweep, которые могут обнаруживать и освобождать память при циклических ссылках, если объекты недостижимы из корней",
      incorrect: "Неверно, современные сборщики мусора могут обрабатывать циклические ссылки, если объекты не достижимы из глобальной области"
    }
  },
  {
    question: "Что такое 'temporal dead zone' для параметров функции?",
    options: [
      "Область между началом функции и инициализацией параметров",
      "Временная зона для дат",
      "Область с ограниченным доступом",
      "Не существует для параметров"
    ],
    answer: "Область между началом функции и инициализацией параметров",
    explanation: {
      correct: "TDZ существует и для параметров функции, особенно при использовании дефолтных значений, которые могут ссылаться на другие параметры",
      incorrect: "Неверно, TDZ существует и для параметров, особенно когда дефолтные значения ссылаются на параметры, которые еще не инициализированы"
    }
  },
  {
    question: "Как работает 'async/await' на низком уровне?",
    options: [
      "Синтаксический сахар над промисами, преобразующийся в цепочку then",
      "Новый тип данных",
      "Специальная функция",
      "Работает через генераторы"
    ],
    answer: "Синтаксический сахар над промисами, преобразующийся в цепочку then",
    explanation: {
      correct: "Async/await - это синтаксический сахар, который транспилируется в цепочку промисов с методами then и catch для упрощения работы с асинхронным кодом",
      incorrect: "Неверно, async/await компилируется в промисы и их цепочки, обеспечивая более читаемый синтаксис для асинхронного кода"
    }
  },
  {
    question: "Что такое 'debouncing' и 'throttling' и в чем их разница?",
    options: [
      "Debouncing откладывает выполнение до паузы, throttling ограничивает частоту вызовов",
      "Одинаковые паттерны",
      "Debouncing быстрее",
      "Throttling менее эффективен"
    ],
    answer: "Debouncing откладывает выполнение до паузы, throttling ограничивает частоту вызовов",
    explanation: {
      correct: "Debouncing откладывает выполнение функции до тех пор, пока не пройдет определенный интервал без вызовов, а throttling гарантирует, что функция вызывается не чаще определенного интервала",
      incorrect: "Неверно, debouncing откладывает выполнение до паузы в вызовах, а throttling ограничивает частоту вызовов независимо от пауз"
    }
  },
  {
    question: "Как работает 'caching' в методах массивов?",
    options: [
      "Методы массивов не кэшируют результаты",
      "Все результаты кэшируются",
      "Кэширование зависит от движка",
      "Кэшируются только простые типы"
    ],
    answer: "Методы массивов не кэшируют результаты",
    explanation: {
      correct: "Методы массивов каждый раз пересчитывают результат, так как массивы могут изменяться, и кэширование привело бы к неконсистентности",
      incorrect: "Неверно, методы массивов не кэшируют результаты, так как массивы являются изменяемыми объектами"
    }
  },
  {
    question: "Что такое 'observable' против 'promise'?",
    options: [
      "Promise - однократное разрешение, observable - поток значений",
      "Одинаковые концепции",
      "Observable быстрее",
      "Promise современнее"
    ],
    answer: "Promise - однократное разрешение, observable - поток значений",
    explanation: {
      correct: "Promise разрешается один раз (успешно или с ошибкой), в то время как Observable может эмитить множество значений во времени и поддерживает отмену подписки",
      incorrect: "Неверно, основное различие в том, что Promise - это однократное разрешение, а Observable - это поток значений, который можно подписывать и отменять"
    }
  },
  {
    question: "Как работает 'property descriptor' в Object.defineProperty()?",
    options: [
      "Определяет атрибуты свойства: configurable, enumerable, writable, value",
      "Шифрует свойства",
      "Создает приватные свойства",
      "Оптимизирует доступ"
    ],
    answer: "Определяет атрибуты свойства: configurable, enumerable, writable, value",
    explanation: {
      correct: "Property descriptor позволяет контролировать, можно ли перечислять свойство, изменять его, удалять и другие атрибуты",
      incorrect: "Неверно, property descriptor - это объект, определяющий поведение свойства: его перечисляемость, изменяемость и другие характеристики"
    }
  },
  {
    question: "Что такое 'weak references' в JavaScript?",
    options: [
      "Ссылки, которые не мешают сборке мусора",
      "Слабые связи между объектами",
      "Ссылки с ограниченным доступом",
      "Ошибочные ссылки"
    ],
    answer: "Ссылки, которые не мешают сборке мусора",
    explanation: {
      correct: "WeakMap и WeakSet содержат слабые ссылки на объекты, которые не предотвращают сборку мусора этих объектов",
      incorrect: "Неверно, weak references - это ссылки, которые не удерживают объекты от удаления сборщиком мусора"
    }
  },
  {
    question: "Как работает 'module loading' в современных браузерах?",
    options: [
      "Асинхронная загрузка с зависимостями",
      "Синхронная загрузка",
      "Загрузка только по требованию",
      "Модули не загружаются"
    ],
    answer: "Асинхронная загрузка с зависимостями",
    explanation: {
      correct: "Модули загружаются асинхронно, разрешая зависимости и кэшируя результаты, что позволяет избежать дублирования и обеспечить правильный порядок загрузки",
      incorrect: "Неверно, модули загружаются асинхронно с разрешением зависимостей и кэшированием"
    }
  },
  {
    question: "Что такое 'isomorphic JavaScript'?",
    options: [
      "Код, который может выполняться и на клиенте, и на сервере",
      "Одно и то же на всех устройствах",
      "Код с одинаковым стилем",
      "Шифрованный код"
    ],
    answer: "Код, который может выполняться и на клиенте, и на сервере",
    explanation: {
      correct: "Isomorphic JavaScript - это код, который может работать как в браузере, так и на сервере (Node.js), что позволяет использовать один код для рендеринга на сервере и клиенте",
      incorrect: "Неверно, isomorphic JavaScript - это подход, при котором один и тот же код может выполняться в разных средах"
    }
  },
  {
    question: "Как работает 'tree shaking' в модульных системах?",
    options: [
      "Удаление неиспользуемого кода на этапе сборки",
      "Оптимизация деревьев DOM",
      "Сжатие кода",
      "Удаление дубликатов"
    ],
    answer: "Удаление неиспользуемого кода на этапе сборки",
    explanation: {
      correct: "Tree shaking - это процесс удаления неиспользуемых экспортируемых функций и переменных на этапе сборки, что уменьшает размер бандла",
      incorrect: "Неверно, tree shaking - это оптимизация сборки, которая удаляет неиспользуемый код из модулей"
    }
  },
  {
    question: "Что такое 'service worker' и как он связан с JavaScript?",
    options: [
      "Скрипт, работающий в фоне, независимо от страницы",
      "Серверный скрипт",
      "Метод оптимизации",
      "Тип веб-воркера"
    ],
    answer: "Скрипт, работающий в фоне, независимо от страницы",
    explanation: {
      correct: "Service worker - это специальный веб-воркер, который работает независимо от страницы и может перехватывать сетевые запросы, кэшировать ресурсы и обеспечивать оффлайн-работу",
      incorrect: "Неверно, service worker - это фоновый скрипт, который может перехватывать запросы и кэшировать ресурсы для PWA"
    }
  },
  {
    question: "Как работает 'caching' в V8 для свойств объектов?",
    options: [
      "Использует hidden classes и inline caching",
      "Кэширует только примитивы",
      "Не использует кэширование",
      "Кэширует только массивы"
    ],
    answer: "Использует hidden classes и inline caching",
    explanation: {
      correct: "V8 использует hidden classes для объектов с одинаковой структурой и inline caching для быстрого доступа к свойствам, что значительно ускоряет выполнение",
      incorrect: "Неверно, V8 использует сложные механизмы кэширования, включая hidden classes и inline caching, для оптимизации доступа к свойствам"
    }
  },
  {
    question: "Что такое 'reactivity' в современных фреймворках?",
    options: [
      "Автоматическое обновление UI при изменении данных",
      "Реакция на события",
      "Быстрая работа",
      "Анимации интерфейса"
    ],
    answer: "Автоматическое обновление UI при изменении данных",
    explanation: {
      correct: "Reactivity - это механизм, при котором изменения в данных автоматически приводят к обновлению соответствующих частей пользовательского интерфейса",
      incorrect: "Неверно, reactivity - это система отслеживания зависимостей, которая автоматически обновляет UI при изменении связанных данных"
    }
  },
  {
    question: "Как работает 'source maps' в разработке JavaScript?",
    options: [
      "Связывают минифицированный код с исходным для отладки",
      "Карты источников данных",
      "Оптимизация кода",
      "Шифрование исходников"
    ],
    answer: "Связывают минифицированный код с исходным для отладки",
    explanation: {
      correct: "Source maps позволяют отлаживать минифицированный и сжатый код, сопоставляя его со строками исходного кода для удобства разработки",
      incorrect: "Неверно, source maps - это файлы, которые связывают транспилированный/минифицированный код с исходными файлами для отладки"
    }
  },
  {
    question: "Что такое 'micro-frontend' архитектура?",
    options: [
      "Архитектура, где приложение состоит из независимых фронтенд-модулей",
      "Маленькие фронтенды",
      "Микросервисы для фронтенда",
      "Оптимизация производительности"
    ],
    answer: "Архитектура, где приложение состоит из независимых фронтенд-модулей",
    explanation: {
      correct: "Micro-frontend - это архитектурный подход, при котором крупное фронтенд-приложение разбивается на независимые, автономные части, которые могут разрабатываться и развертываться отдельно",
      incorrect: "Неверно, micro-frontend - это подход к архитектуре, где приложение состоит из независимых фронтенд-компонентов, разрабатываемых разными командами"
    }
  }
];