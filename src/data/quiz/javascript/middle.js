export default [
  {
    question: "Что выведет console.log(typeof []) в JavaScript?",
    options: ["'array'", "'object'", "'list'", "'undefined'"],
    answer: "'object'",
    explanation: {
      correct: "В JavaScript массивы являются объектами, поэтому typeof возвращает 'object'",
      incorrect: "Неверно, несмотря на то что это массив, typeof возвращает 'object' потому что массивы - это объекты в JavaScript"
    }
  },
  {
    question: "Что такое замыкание (closure) в JavaScript?",
    options: [
      "Функция, которая имеет доступ к переменным из внешней области видимости",
      "Метод для закрытия модальных окон",
      "Специальный тип объекта",
      "Функция, которая вызывает сама себя"
    ],
    answer: "Функция, которая имеет доступ к переменным из внешней области видимости",
    explanation: {
      correct: "Замыкание - это функция, которая запоминает свои внешние переменные и может получать к ним доступ",
      incorrect: "Неверно, замыкание - это функция, которая имеет доступ к переменным из своей внешней области видимости, даже после завершения выполнения этой области"
    }
  },
  {
    question: "Что выведет следующий код: console.log(0.1 + 0.2 === 0.3)?",
    options: ["true", "false", "undefined", "NaN"],
    answer: "false",
    explanation: {
      correct: "Из-за особенностей представления чисел с плавающей точкой в двоичной системе, 0.1 + 0.2 не равно точно 0.3",
      incorrect: "Неверно, из-за ошибок округления в представлении чисел с плавающей точкой 0.1 + 0.2 дает примерно 0.30000000000000004, что не равно 0.3"
    }
  },
  {
    question: "Что делает метод Array.prototype.reduce()?",
    options: [
      "Преобразует каждый элемент массива",
      "Фильтрует элементы массива",
      "Выполняет функцию редуктора для каждого элемента, возвращая одно значение",
      "Сортирует элементы массива"
    ],
    answer: "Выполняет функцию редуктора для каждого элемента, возвращая одно значение",
    explanation: {
      correct: "Метод reduce() применяет функцию к аккумулятору и каждому значению массива, сводя его к одному значению",
      incorrect: "Неверно, reduce() используется для свертки массива в одно значение, в то время как map() преобразует элементы, а filter() фильтрует их"
    }
  },
  {
    question: "Что такое event loop в JavaScript?",
    options: [
      "Цикл, который проверяет наличие событий в DOM",
      "Механизм, который обрабатывает выполнение кода, события и вызовы обратного вызова",
      "Специальный тип цикла for",
      "Функция для обработки ошибок"
    ],
    answer: "Механизм, который обрабатывает выполнение кода, события и вызовы обратного вызова",
    explanation: {
      correct: "Event loop - это механизм, который отслеживает стек вызовов и очередь колбэков, позволяя JavaScript быть однопоточным, но асинхронным",
      incorrect: "Неверно, event loop - это основной механизм асинхронности в JavaScript, который управляет выполнением кода и обработкой событий"
    }
  },
  {
    question: "Что выведет console.log(JSON.stringify({a: undefined, b: function(){}, c: NaN}))?",
    options: [
      '{"a":undefined,"b":function(){},"c":NaN}',
      '{"c":null}',
      '{"c":NaN}',
      '{}'
    ],
    answer: '{}',
    explanation: {
      correct: "JSON.stringify() пропускает свойства со значением undefined, функции и символы, а также преобразует NaN в null, но в данном случае остается пустой объект",
      incorrect: "Неверно, JSON.stringify() исключает undefined, функции и NaN (который становится null), поэтому остается пустой объект"
    }
  },
  {
    question: "Какой метод используется для предотвращения всплытия события?",
    options: [
      "event.stopPropagation()",
      "event.preventDefault()",
      "event.stopImmediatePropagation()",
      "event.cancelBubble()"
    ],
    answer: "event.stopPropagation()",
    explanation: {
      correct: "Метод stopPropagation() предотвращает дальнейшее всплытие события в дереве DOM",
      incorrect: "Неверно, stopPropagation() останавливает всплытие события, в то время как preventDefault() отменяет действие по умолчанию"
    }
  },
  {
    question: "Что такое прототипное наследование в JavaScript?",
    options: [
      "Наследование через ключевое слово extends",
      "Механизм, при котором объекты могут наследовать свойства и методы от других объектов через цепочку прототипов",
      "Способ создания приватных свойств",
      "Тип наследования, используемый только в классах"
    ],
    answer: "Механизм, при котором объекты могут наследовать свойства и методы от других объектов через цепочку прототипов",
    explanation: {
      correct: "Прототипное наследование - это основа объектной системы в JavaScript, где объекты наследуют свойства от других объектов через свойство __proto__ или прототип конструктора",
      incorrect: "Неверно, прототипное наследование - это фундаментальный механизм JavaScript, позволяющий объектам наследовать свойства через цепочку прототипов"
    }
  },
  {
    question: "Что делает оператор 'in' в JavaScript?",
    options: [
      "Проверяет, содержится ли значение в массиве",
      "Проверяет, существует ли свойство в объекте (включая унаследованные)",
      "Определяет тип переменной",
      "Проверяет, является ли значение числом"
    ],
    answer: "Проверяет, существует ли свойство в объекте (включая унаследованные)",
    explanation: {
      correct: "Оператор 'in' возвращает true, если указанное свойство находится в объекте или его прототипной цепочке",
      incorrect: "Неверно, оператор 'in' проверяет наличие свойства в объекте, включая унаследованные свойства, в отличие от hasOwnProperty()"
    }
  },
  {
    question: "Что такое 'this' в стрелочных функциях?",
    options: [
      "Указывает на глобальный объект",
      "Указывает на объект, которому принадлежит функция",
      "Наследует значение 'this' из окружающего контекста",
      "Всегда undefined"
    ],
    answer: "Наследует значение 'this' из окружающего контекста",
    explanation: {
      correct: "Стрелочные функции не имеют собственного 'this', они наследуют его из окружающей области видимости",
      incorrect: "Неверно, стрелочные функции не привязывают собственный 'this', а используют значение 'this' из внешнего лексического контекста"
    }
  },
  {
    question: "Что выведет следующий код: console.log([1, 2] + [3, 4])?",
    options: ["[1,2,3,4]", "6", "1,23,4", "1,2,3,4"],
    answer: "1,23,4",
    explanation: {
      correct: "При сложении массивов они преобразуются в строки, поэтому результат - конкатенация строк '1,2' и '3,4'",
      incorrect: "Неверно, при сложении массивов происходит их преобразование в строки и конкатенация, а не объединение массивов"
    }
  },
  {
    question: "Что делает метод Object.defineProperty()?",
    options: [
      "Добавляет новое свойство к объекту с возможностью настройки его атрибутов",
      "Удаляет свойство из объекта",
      "Изменяет прототип объекта",
      "Создает новый объект"
    ],
    answer: "Добавляет новое свойство к объекту с возможностью настройки его атрибутов",
    explanation: {
      correct: "Object.defineProperty() позволяет добавлять или изменять свойства с возможностью контроля их перечисляемости, изменяемости и настраиваемости",
      incorrect: "Неверно, этот метод используется для определения новых свойств или изменения существующих с детальным контролем их атрибутов"
    }
  },
  {
    question: "Что такое мемоизация в JavaScript?",
    options: [
      "Процесс шифрования данных",
      "Техника кэширования результатов функции для повторного использования",
      "Метод оптимизации DOM",
      "Способ минификации кода"
    ],
    answer: "Техника кэширования результатов функции для повторного использования",
    explanation: {
      correct: "Мемоизация - это оптимизационная техника, при которой результаты функции кэшируются для одинаковых входных параметров",
      incorrect: "Неверно, мемоизация - это техника оптимизации, при которой результаты функции сохраняются для повторного использования с теми же аргументами"
    }
  },
  {
    question: "Что выведет console.log(Promise.resolve().then(() => console.log(1)).then(() => console.log(2)))?",
    options: ["1 2", "2 1", "1 undefined 2", "undefined 1 2"],
    answer: "1 2",
    explanation: {
      correct: "Промисы выполняются асинхронно, но в порядке очереди, поэтому сначала выведется 1, затем 2",
      incorrect: "Неверно, промисы выполняются в порядке их цепочки, поэтому сначала выполнится первый then с console.log(1), затем второй с console.log(2)"
    }
  },
  {
    question: "Что такое деструктуризация в JavaScript?",
    options: [
      "Процесс удаления объектов из памяти",
      "Синтаксис для извлечения значений из массивов или свойств из объектов",
      "Метод для уничтожения переменных",
      "Техника оптимизации кода"
    ],
    answer: "Синтаксис для извлечения значений из массивов или свойств из объектов",
    explanation: {
      correct: "Деструктуризация позволяет извлекать данные из массивов или объектов в отдельные переменные с помощью синтаксиса, подобного литералам массивов/объектов",
      incorrect: "Неверно, деструктуризация - это синтаксис для извлечения значений из массивов или свойств объектов в переменные"
    }
  },
  {
    question: "Что делает метод Array.prototype.flatMap()?",
    options: [
      "Преобразует каждый элемент массива и сглаживает результат",
      "Фильтрует и сортирует массив",
      "Объединяет два массива",
      "Преобразует массив в строку"
    ],
    answer: "Преобразует каждый элемент массива и сглаживает результат",
    explanation: {
      correct: "flatMap() сначала применяет функцию к каждому элементу (как map), а затем сглаживает результат на одну глубину (как flat)",
      incorrect: "Неверно, flatMap() объединяет функциональность map и flat, преобразуя элементы и сглаживая результат"
    }
  },
  {
    question: "Что такое Event Bubbling в JavaScript?",
    options: [
      "Процесс создания новых событий",
      "Распространение события от целевого элемента к корневому элементу",
      "Отмена события",
      "Создание кастомных событий"
    ],
    answer: "Распространение события от целевого элемента к корневому элементу",
    explanation: {
      correct: "Event Bubbling - это процесс, при котором событие сначала обрабатывается на целевом элементе, а затем последовательно всплывает к родительским элементам",
      incorrect: "Неверно, event bubbling - это механизм всплытия события от целевого элемента к корневому элементу документа"
    }
  },
  {
    question: "Что выведет console.log(Number('123abc'))?",
    options: ["123", "NaN", "123abc", "undefined"],
    answer: "NaN",
    explanation: {
      correct: "Number() возвращает NaN, если строка содержит нецифровые символы, которые не могут быть интерпретированы как число",
      incorrect: "Неверно, Number('123abc') возвращает NaN, потому что строка содержит нецифровые символы в конце"
    }
  },
  {
    question: "Что такое Temporal Dead Zone (TDZ) в JavaScript?",
    options: [
      "Область, где переменные не могут быть доступны до их инициализации",
      "Временная зона для дат",
      "Область с ограниченным доступом к памяти",
      "Зона для временных переменных"
    ],
    answer: "Область, где переменные не могут быть доступны до их инициализации",
    explanation: {
      correct: "TDZ - это период между началом области видимости и моментом, когда переменная инициализируется, в течение которого доступ к переменной вызывает ошибку",
      incorrect: "Неверно, TDZ - это концепция, связанная с переменными, объявленными через let и const, которые не могут быть доступны до их инициализации"
    }
  },
  {
    question: "Что делает оператор ?? (Nullish Coalescing)?",
    options: [
      "Проверяет, является ли значение null или undefined",
      "Возвращает правый операнд, если левый операнд является null или undefined",
      "Проверяет, является ли значение falsy",
      "Объединяет два значения"
    ],
    answer: "Возвращает правый операнд, если левый операнд является null или undefined",
    explanation: {
      correct: "Оператор ?? возвращает правый операнд, только если левый операнд является null или undefined, в отличие от ||, который проверяет falsy значения",
      incorrect: "Неверно, ?? проверяет только null и undefined, в то время как || проверяет все falsy значения"
    }
  },
  {
    question: "Что такое микрозадачи (microtasks) в JavaScript?",
    options: [
      "Маленькие функции",
      "Задачи, которые выполняются после каждого макрозадачи",
      "Асинхронные операции, которые имеют более высокий приоритет, чем макрозадачи",
      "Синхронные операции"
    ],
    answer: "Асинхронные операции, которые имеют более высокий приоритет, чем макрозадачи",
    explanation: {
      correct: "Микрозадачи (например, промисы) имеют более высокий приоритет, чем макрозадачи (например, setTimeout), и выполняются перед следующей итерацией event loop",
      incorrect: "Неверно, микрозадачи - это асинхронные операции с высоким приоритетом, которые выполняются перед макрозадачами"
    }
  },
  {
    question: "Что выведет console.log(JSON.parse(JSON.stringify({a: {b: 1}})).a === {a: {b: 1}}.a)?",
    options: ["true", "false", "undefined", "TypeError"],
    answer: "false",
    explanation: {
      correct: "Сравнение объектов по ссылке возвращает false, даже если их содержимое идентично",
      incorrect: "Неверно, при сравнении объектов сравниваются ссылки, а не содержимое, поэтому результат false"
    }
  },
  {
    question: "Что делает метод Object.create()?",
    options: [
      "Создает новый объект с указанным прототипом",
      "Создает копию объекта",
      "Преобразует объект в массив",
      "Удаляет объект"
    ],
    answer: "Создает новый объект с указанным прототипом",
    explanation: {
      correct: "Object.create() создает новый объект, используя существующий объект в качестве прототипа для создаваемого объекта",
      incorrect: "Неверно, Object.create() используется для создания нового объекта с указанным прототипом"
    }
  },
  {
    question: "Что такое IIFE (Immediately Invoked Function Expression)?",
    options: [
      "Функция, которая вызывается немедленно после своего определения",
      "Функция, которая вызывается через определенное время",
      "Асинхронная функция",
      "Стрелочная функция"
    ],
    answer: "Функция, которая вызывается немедленно после своего определения",
    explanation: {
      correct: "IIFE - это функция, которая выполняется сразу после создания, часто используется для создания отдельной области видимости",
      incorrect: "Неверно, IIFE - это функция, которая вызывается немедленно после своего определения, что позволяет изолировать переменные"
    }
  },
  {
    question: "Что выведет console.log([...'hello'])?",
    options: ["['h', 'e', 'l', 'l', 'o']", "'hello'", "['hello']", "h e l l o"],
    answer: "['h', 'e', 'l', 'l', 'o']",
    explanation: {
      correct: "Оператор расширения (...) разбивает строку на отдельные символы, создавая массив",
      incorrect: "Неверно, оператор расширения применяет итерацию к строке, создавая массив из отдельных символов"
    }
  },
  {
    question: "Что такое прототип в JavaScript?",
    options: [
      "Шаблон для создания объектов",
      "Объект, от которого наследуют другие объекты",
      "Метод для клонирования объектов",
      "Специальный тип данных"
    ],
    answer: "Объект, от которого наследуют другие объекты",
    explanation: {
      correct: "Прототип - это объект, который используется в качестве шаблона для других объектов, обеспечивая наследование свойств и методов",
      incorrect: "Неверно, прототип - это объект, от которого наследуют другие объекты в JavaScript"
    }
  },
  {
    question: "Что делает метод Array.prototype.some()?",
    options: [
      "Проверяет, удовлетворяет ли хотя бы один элемент массива условию",
      "Проверяет, удовлетворяют ли все элементы массива условию",
      "Фильтрует элементы массива",
      "Находит первый элемент, удовлетворяющий условию"
    ],
    answer: "Проверяет, удовлетворяет ли хотя бы один элемент массива условию",
    explanation: {
      correct: "Метод some() возвращает true, если хотя бы один элемент массива проходит проверку, заданную в функции",
      incorrect: "Неверно, some() проверяет, удовлетворяет ли хотя бы один элемент условию, в то время как every() проверяет все элементы"
    }
  },
  {
    question: "Что такое strict mode в JavaScript?",
    options: [
      "Режим, который делает код более строгим и безопасным",
      "Режим для оптимизации производительности",
      "Режим для отладки",
      "Режим для работы с массивами"
    ],
    answer: "Режим, который делает код более строгим и безопасным",
    explanation: {
      correct: "Strict mode вводит дополнительные ограничения и ошибки для предотвращения распространенных ошибок и неоднозначных конструкций",
      incorrect: "Неверно, strict mode - это режим, который делает JavaScript более строгим, выявляя потенциальные ошибки"
    }
  },
  {
    question: "Что выведет console.log(!!'false')?",
    options: ["true", "false", "'false'", "undefined"],
    answer: "true",
    explanation: {
      correct: "Любая непустая строка является truthy значением, поэтому !!'false' вернет true",
      incorrect: "Неверно, несмотря на то что строка содержит 'false', сама строка является truthy значением"
    }
  },
  {
    question: "Что делает метод Object.freeze()?",
    options: [
      "Предотвращает добавление новых свойств, удаление существующих и изменение существующих",
      "Позволяет изменять свойства, но не добавлять новые",
      "Полностью удаляет объект",
      "Блокирует доступ к объекту"
    ],
    answer: "Предотвращает добавление новых свойств, удаление существующих и изменение существующих",
    explanation: {
      correct: "Object.freeze() делает объект неизменяемым, предотвращая любые изменения его свойств",
      incorrect: "Неверно, Object.freeze() полностью замораживает объект, делая его неизменяемым"
    }
  }
];