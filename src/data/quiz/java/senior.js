export default [
  {
    question: "Как работает механизм escape analysis в HotSpot JVM?",
    options: [
      "Определяет, может ли объект быть выделен на стеке вместо кучи",
      "Анализирует исключения в коде",
      "Оптимизирует строковые операции",
      "Проверяет выход за границы массивов"
    ],
    answer: "Определяет, может ли объект быть выделен на стеке вместо кучи",
    explanation: {
      correct: "Escape analysis определяет область видимости объектов и позволяет JVM размещать их на стеке (stack allocation) или вообще устранять выделение памяти (scalar replacement), если объект не 'побегает' за пределы метода",
      incorrect: "Неверно, escape analysis - это оптимизация JVM, которая анализирует, может ли объект быть безопасно выделен на стеке или его поля могут быть представлены как скалярные переменные"
    }
  },
  {
    question: "Что такое biased locking и как он влияет на производительность?",
    options: [
      "Оптимизация, предполагающая, что один поток будет чаще захватывать монитор",
      "Блокировка с приоритетом",
      "Оптимизация для многопроцессорных систем",
      "Метод для избежания deadlock"
    ],
    answer: "Оптимизация, предполагающая, что один поток будет чаще захватывать монитор",
    explanation: {
      correct: "Biased locking предполагает, что монитор, как правило, захватывается одним и тем же потоком, что позволяет избежать накладных расходов на CAS-операции при повторном захвате",
      incorrect: "Неверно, biased locking - это оптимизация синхронизации, которая предполагает, что монитор будет захватываться одним потоком, уменьшая накладные расходы"
    }
  },
  {
    question: "Как JVM реализует inline caching для вызовов методов?",
    options: [
      "Кэширует целевой метод на основе типа объекта",
      "Инлайнит все методы",
      "Кэширует только статические методы",
      "Использует хеш-таблицы для всех вызовов"
    ],
    answer: "Кэширует целевой метод на основе типа объекта",
    explanation: {
      correct: "Inline caching запоминает целевой метод для конкретного типа объекта, что ускоряет виртуальные вызовы методов, особенно когда тип объекта предсказуем",
      incorrect: "Неверно, inline caching - это оптимизация, при которой JVM кэширует информацию о целевом методе на основе типа объекта для ускорения виртуальных вызовов"
    }
  },
  {
    question: "Что такое G1 Garbage Collector и в чем его основное преимущество?",
    options: [
      "Сборщик с предсказуемыми паузами, разделяющий кучу на регионы",
      "Самый быстрый сборщик",
      "Только для больших приложений",
      "Не использует параллелизм"
    ],
    answer: "Сборщик с предсказуемыми паузами, разделяющий кучу на регионы",
    explanation: {
      correct: "G1GC разделяет кучу на регионы и позволяет задавать целевые максимальные паузы, приоритизируя сборку регионов с наибольшим количеством мусора",
      incorrect: "Неверно, G1GC - это сборщик с регионами, который стремится обеспечить предсказуемые паузы, фокусируясь на регионах с наибольшим количеством мусора"
    }
  },
  {
    question: "Как работает механизм speculative optimization в JIT-компиляторе?",
    options: [
      "Генерирует оптимизированный код на основе предположений, с возможностью отката",
      "Оптимизирует только проверенный код",
      "Работает только с примитивами",
      "Не использует предположения"
    ],
    answer: "Генерирует оптимизированный код на основе предположений, с возможностью отката",
    explanation: {
      correct: "JIT делает предположения (например, о типах объектов или отсутствии переопределения методов) и генерирует высокооптимизированный код, который может быть деоптимизирован при нарушении предположений",
      incorrect: "Неверно, speculative optimization - это когда JIT-компилятор делает предположения и генерирует оптимизированный код, который может быть деоптимизирован при их нарушении"
    }
  },
  {
    question: "Что такое lock elision и как он реализуется?",
    emptyOptions: [
      "Устранение блокировок при анализе потока выполнения",
      "Удаление избыточных синхронизаций",
      "Оптимизация для мониторов",
      "Все перечисленные"
    ],
    answer: "Все перечисленные",
    explanation: {
      correct: "Lock elision - это серия оптимизаций (включая lock coarsening, lock elimination, lock fusion), при которых JVM может устранять, объединять или перестраивать блокировки на основе анализа кода",
      incorrect: "Неверно, lock elision включает несколько техник оптимизации синхронизации, которые уменьшают или устраняют накладные расходы на блокировки"
    }
  },
  {
    question: "Как JVM обрабатывает вызовы виртуальных методов при наличии инлайн-кэширования?",
    options: [
      "Использует кэш для быстрого разрешения целевого метода",
      "Всегда выполняет полный поиск",
      "Инлайнит все виртуальные вызовы",
      "Заменяет на статические вызовы"
    ],
    answer: "Использует кэш для быстрого разрешения целевого метода",
    explanation: {
      correct: "Inline caching сохраняет информацию о последнем/последних типах объектов и соответствующих методах, что позволяет быстро разрешать большинство виртуальных вызовов без полного поиска в vtable",
      incorrect: "Неверно, inline caching позволяет JVM быстро разрешать виртуальные вызовы, кэшируя результаты предыдущих разрешений"
    }
  },
  {
    question: "Что такое value types (предполагаемая фича) и как они могут повлиять на производительность?",
    options: [
      "Типы, которые могут быть размещены в стеке и не требуют выделения памяти в куче",
      "Новые примитивы",
      "Обертки для примитивов",
      "Типы только для чтения"
    ],
    answer: "Типы, которые могут быть размещены в стеке и не требуют выделения памяти в куче",
    explanation: {
      correct: "Value types (планируемая фича) позволят создавать объекты-значения, которые могут быть размещены в стеке, инлайнены в другие объекты и не требуют выделения памяти в куче, что значительно повысит производительность",
      incorrect: "Неверно, value types - это концепция, позволяющая создавать объекты, которые ведут себя как примитивы по производительности, но имеют синтаксис классов"
    }
  },
  {
    question: "Как работает механизм deoptimization в HotSpot JVM?",
    options: [
      "Возврат к интерпретируемому коду при нарушении предположений JIT",
      "Удаление оптимизаций",
      "Остановка JIT-компилятора",
      "Перезапуск JVM"
    ],
    answer: "Возврат к интерпретируемому коду при нарушении предположений JIT",
    explanation: {
      correct: "Deoptimization происходит, когда предположения, на которых основывалась JIT-оптимизация, нарушаются (например, появление нового подкласса), и JVM возвращается к интерпретируемому коду",
      incorrect: "Неверно, deoptimization - это процесс, при котором JVM откатывает оптимизированный код к интерпретируемому при нарушении предположений"
    }
  },
  {
    question: "Что такое Shenandoah GC и чем он отличается от других сборщиков?",
    options: [
      "Сборщик с очень короткими паузами, использующий concurrent compaction",
      "Самый старый сборщик",
      "Только для малых куч",
      "Не использует потоки"
    ],
    answer: "Сборщик с очень короткими паузами, использующий concurrent compaction",
    explanation: {
      correct: "Shenandoah GC выполняет большую часть работы (включая компактификацию) параллельно с приложением, что обеспечивает очень короткие паузы независимо от размера кучи",
      incorrect: "Неверно, Shenandoah - это low-pause сборщик, который выполняет компактификацию одновременно с работой приложения"
    }
  },
  {
    question: "Как JVM реализует intrinsic methods?",
    options: [
      "Заменяет вызовы на специальные машинные инструкции",
      "Инлайнит все методы",
      "Удаляет вызовы",
      "Заменяет на нативные реализации"
    ],
    answer: "Заменяет вызовы на специальные машинные инструкции",
    explanation: {
      correct: "Intrinsic methods - это методы, которые JVM заменяет на специальные эффективные машинные инструкции (например, System.arraycopy может использовать SIMD-инструкции)",
      incorrect: "Неверно, intrinsic methods - это когда JVM заменяет вызовы определенных методов на высокооптимизированные машинные инструкции"
    }
  },
  {
    question: "Что такое metaspace и как он отличается от permanent generation?",
    options: [
      "Область памяти для метаданных классов, не имеющая фиксированного размера",
      "Новое место для хранения объектов",
      "Замена heap",
      "Область для примитивов"
    ],
    answer: "Область памяти для метаданных классов, не имеющая фиксированного размера",
    explanation: {
      correct: "Metaspace заменил PermGen в Java 8+, использует нативную память и может динамически расширяться, что устраняет проблемы с OutOfMemoryError",
      incorrect: "Неверно, metaspace - это область для хранения метаданных классов, которая использует нативную память и может расти динамически"
    }
  },
  {
    question: "Как работает механизм biased locking revocation?",
    options: [
      "Отзывает предвзятость при конкуренции за монитор",
      "Удаляет все блокировки",
      "Останавливает потоки",
      "Перезапускает JVM"
    ],
    answer: "Отзывает предвзятость при конкуренции за монитор",
    explanation: {
      correct: "Когда другой поток пытается захватить предвзятый монитор, происходит revocation - монитор становится глобально ревокабельным и больше не может быть предвзятым",
      incorrect: "Неверно, biased locking revocation происходит при конкуренции за монитор и делает его недоступным для будущей предвзятости"
    }
  },
  {
    question: "Что такое AOT (Ahead-of-Time) compilation в GraalVM?",
    options: [
      "Компиляция в нативный код до запуска приложения",
      "Оптимизация во время выполнения",
      "Интерпретация кода",
      "Динамическая компиляция"
    ],
    answer: "Компиляция в нативный код до запуска приложения",
    explanation: {
      correct: "AOT компиляция в GraalVM позволяет компилировать Java-приложения в нативные исполняемые файлы, что уменьшает время запуска и потребление памяти",
      incorrect: "Неверно, AOT compilation - это компиляция в нативный код до выполнения, в отличие от JIT, который компилирует во время выполнения"
    }
  },
  {
    question: "Как JVM обрабатывает вызовы методов через интерфейсы?",
    options: [
      "Использует method resolution и inline caching",
      "Всегда использует медленный поиск",
      "Заменяет на вызовы классов",
      "Не может оптимизировать"
    ],
    answer: "Использует method resolution и inline caching",
    explanation: {
      correct: "JVM использует различные техники, включая inline caching и method resolution, для оптимизации вызовов интерфейсных методов, особенно когда ведется о конкретной реализации",
      incorrect: "Неверно, современные JVM эффективно оптимизируют вызовы интерфейсных методов с помощью различных техник, включая кэширование"
    }
  },
  {
    question: "Что такое escape analysis scalar replacement?",
    options: [
      "Замена объекта его полями-переменными",
      "Удаление объекта",
      "Перемещение объекта",
      "Копирование объекта"
    ],
    answer: "Замена объекта его полями-переменными",
    explanation: {
      correct: "Scalar replacement - это оптимизация, при которой объект, не 'побегавший' за пределы метода, представляется не как объект в куче, а как набор скалярных переменных (полей)",
      incorrect: "Неверно, scalar replacement - это когда JVM представляет объект как набор отдельных переменных, избегая выделения памяти для объекта"
    }
  },
  {
    question: "Как работает механизм monitor inflation?",
    options: [
      "Преобразование легковесной блокировки в полную системную",
      "Увеличение размера монитора",
      "Создание дополнительных мониторов",
      "Оптимизация блокировок"
    ],
    answer: "Преобразование легковесной блокировки в полную системную",
    explanation: {
      correct: "Monitor inflation происходит, когда легковесная (thin) блокировка преобразуется в полную (heavyweight) системную мониторную структуру при конкуренции за объект",
      incorrect: "Неверно, monitor inflation - это процесс преобразования оптимизированной блокировки в полную системную структуру при возникновении конкуренции"
    }
  },
  {
    question: "Что такое JVM TI (Tool Interface)?",
    options: [
      "Нативный интерфейс для инструментирования JVM",
      "Интерфейс для разработчиков",
      "API для мониторинга",
      "Инструмент для отладки"
    ],
    answer: "Нативный интерфейс для инструментирования JVM",
    explanation: {
      correct: "JVM TI - это нативный интерфейс, который позволяет создавать агентов для инструментирования, отладки и мониторинга JVM",
      incorrect: "Неверно, JVM TI - это нативный API, используемый для создания инструментов, таких как отладчики и профайлеры"
    }
  },
  {
    question: "Как JVM реализует оптимизацию loop unrolling?",
    options: [
      "Развертывание тела цикла для уменьшения накладных расходов",
      "Удаление циклов",
      "Замена циклов на рекурсию",
      "Оптимизация условий"
    ],
    answer: "Развертывание тела цикла для уменьшения накладных расходов",
    explanation: {
      correct: "Loop unrolling - это оптимизация, при которой тело цикла дублируется несколько раз, уменьшая количество итераций и накладные расходы на проверку условия",
      incorrect: "Неверно, loop unrolling - это когда JIT-компилятор разворачивает тело цикла, чтобы уменьшить количество итераций и накладные расходы"
    }
  },
  {
    question: "Что такое JFR (Java Flight Recorder) и для чего он используется?",
    options: [
      "Система профилирования и сбора диагностических данных",
      "Рекордер исключений",
      "Система логирования",
      "Менеджер памяти"
    ],
    answer: "Система профилирования и сбора диагностических данных",
    explanation: {
      correct: "JFR - это встроенный в JVM профайлер, который собирает подробные диагностические данные о производительности и поведении приложения с минимальными накладными расходами",
      incorrect: "Неверно, JFR - это мощный инструмент профилирования, встроенный в JVM, для сбора данных о производительности и диагностике"
    }
  },
  {
    question: "Как работает механизм compressed oops в JVM?",
    options: [
      "Использует 32-битные указатели на объекты в 64-битной JVM",
      "Сжимает объекты в памяти",
      "Уменьшает размер примитивов",
      "Оптимизирует массивы"
    ],
    answer: "Использует 32-битные указатели на объекты в 64-битной JVM",
    explanation: {
      correct: "Compressed OOPs позволяет использовать 32-битные смещения для ссылок на объекты в 64-битной JVM, что экономит память при размере кучи до ~32GB",
      incorrect: "Неверно, compressed oops - это оптимизация, при которой 64-битная JVM использует 32-битные указатели на объекты, экономя память"
    }
  },
  {
    question: "Что такое method inlining в JIT-компиляторе?",
    options: [
      "Вставка тела метода в место вызова",
      "Удаление метода",
      "Замена на интерфейс",
      "Оптимизация вызовов"
    ],
    answer: "Вставка тела метода в место вызова",
    explanation: {
      correct: "Method inlining - это ключевая оптимизация, при которой JIT вставляет тело метода непосредственно в место вызова, устраняя накладные расходы на вызов",
      incorrect: "Неверно, method inlining - это когда JIT-компилятор вставляет код метода в место вызова, устраняя накладные расходы"
    }
  },
  {
    question: "Как JVM обрабатывает вызовы статических методов?",
    options: [
      "Прямой вызов без разрешения",
      "Через виртуальные таблицы",
      "С помощью интерфейсов",
      "Всегда инлайнит"
    ],
    answer: "Прямой вызов без разрешения",
    explanation: {
      correct: "Вызовы статических методов разрешаются на этапе компиляции и выполняются напрямую, без необходимости в динамическом разрешении как у виртуальных методов",
      incorrect: "Неверно, статические методы вызываются напрямую, так как их целевой метод известен на этапе компиляции"
    }
  },
  {
    question: "Что такое GraalVM и чем он отличается от традиционной JVM?",
    options: [
      "Многоязыковая виртуальная машина с AOT компиляцией",
      "Новый сборщик мусора",
      "Оптимизация для Java 8",
      "Замена JIT"
    ],
    answer: "Многоязыковая виртуальная машина с AOT компиляцией",
    explanation: {
      correct: "GraalVM - это расширенная JVM, поддерживающая несколько языков и предлагающая AOT компиляцию для создания нативных образов с быстрым стартом",
      incorrect: "Неверно, GraalVM - это универсальная платформа, поддерживающая несколько языков и предлагающая как JIT, так и AOT компиляцию"
    }
  },
  {
    question: "Как работает механизм lock coarsening?",
    options: [
      "Объединение нескольких блокировок в одну",
      "Укрупнение мониторов",
      "Создание более сильных блокировок",
      "Оптимизация условий"
    ],
    answer: "Объединение нескольких блокировок в одну",
    explanation: {
      correct: "Lock coarsening объединяет несколько последовательных операций синхронизации в одну более крупную блокировку, уменьшая накладные расходы",
      incorrect: "Неверно, lock coarsening - это оптимизация, при которой JVM объединяет несколько близких операций синхронизации в одну"
    }
  },
  {
    question: "Что такое JMH (Java Microbenchmark Harness)?",
    options: [
      "Фреймворк для написания корректных микробенчмарков",
      "Система мониторинга",
      "Профайлер",
      "Отладчик"
    ],
    answer: "Фреймворк для написания корректных микробенчмарков",
    explanation: {
      correct: "JMH - это официальный инструмент для написания микро-бенчмарков в Java, учитывающий особенности JVM, такие как JIT-компиляция и оптимизации",
      incorrect: "Неверно, JMH - это специализированный фреймворк для создания надежных микробенчмарков, учитывающий особенности работы JVM"
    }
  },
  {
    question: "Как JVM обрабатывает вызовы final методов?",
    options: [
      "Может инлайнить и не использовать виртуальные вызовы",
      "Всегда использует виртуальные вызовы",
      "Заменяет на статические",
      "Не может оптимизировать"
    ],
    answer: "Может инлайнить и не использовать виртуальные вызовы",
    explanation: {
      correct: "Вызовы final методов могут быть инлайнены и не требуют динамического разрешения, так как метод не может быть переопределен",
      incorrect: "Неверно, final методы могут быть инлайнены JIT-компилятором, так как их реализация известна и не может быть изменена"
    }
  },
  {
    question: "Что такое C2 и C1 компиляторы в HotSpot JVM?",
    options: [
      "C1 - быстрый компилятор, C2 - оптимизирующий",
      "C1 - для клиентов, C2 - для серверов",
      "C1 - устаревший, C2 - новый",
      "C1 - для примитивов, C2 - для объектов"
    ],
    answer: "C1 - быстрый компилятор, C2 - оптимизирующий",
    explanation: {
      correct: "C1 (Client Compiler) быстро компилирует код с базовыми оптимизациями, C2 (Server Compiler) выполняет глубокие оптимизации для долгоживущих методов",
      incorrect: "Неверно, C1 - это быстрый компилятор с базовыми оптимизациями, C2 - глубоко оптимизирующий компилятор для серверных приложений"
    }
  },
  {
    question: "Как работает механизм card table в сборщиках мусора?",
    options: [
      "Отслеживает изменения в объектах, указывающих на молодое поколение",
      "Таблица для карточек памяти",
      "Система учета объектов",
      "Индекс для поиска"
    ],
    answer: "Отслеживает изменения в объектах, указывающих на молодое поколение",
    explanation: {
      correct: "Card table используется в generational GC для отслеживания записей в старом поколении, которые могут указывать на молодое, что позволяет эффективно собирать молодое поколение",
      incorrect: "Неверно, card table - это структура данных, отслеживающая изменения в старом поколении, которые могут указывать на объекты в молодом поколении"
    }
  },
  {
    question: "Что такое ZGC и какие у него основные характеристики?",
    options: [
      "Сборщик с паузами менее 10ms при больших объемах памяти",
      "Самый старый сборщик",
      "Только для малых куч",
      "Не использует потоки"
    ],
    answer: "Сборщик с паузами менее 10ms при больших объемах памяти",
    explanation: {
      correct: "ZGC - это scalable low-latency сборщик мусора, который обеспечивает паузы менее 10ms даже при размерах кучи до нескольких терабайт",
      incorrect: "Неверно, ZGC - это современный сборщик, разработанный для больших куч с минимальными паузами"
    }
  }
];