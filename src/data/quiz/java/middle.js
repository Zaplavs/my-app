export default [
  {
    question: "Что такое JVM и какова ее основная функция?",
    options: [
      "Виртуальная машина, которая выполняет байт-код Java",
      "Система управления памятью",
      "Компилятор Java-кода",
      "Фреймворк для разработки приложений"
    ],
    answer: "Виртуальная машина, которая выполняет байт-код Java",
    explanation: {
      correct: "JVM (Java Virtual Machine) выполняет скомпилированный байт-код Java, обеспечивая кроссплатформенность",
      incorrect: "Неверно, JVM - это виртуальная машина, которая выполняет байт-код Java, обеспечивая работу на разных платформах"
    }
  },
  {
    question: "Чем отличается ArrayList от LinkedList в Java?",
    options: [
      "ArrayList использует массив, LinkedList - двусвязный список",
      "ArrayList быстрее для вставки, LinkedList - для поиска",
      "ArrayList не позволяет дубликаты, LinkedList - позволяет",
      "ArrayList синхронизирован, LinkedList - нет"
    ],
    answer: "ArrayList использует массив, LinkedList - двусвязный список",
    explanation: {
      correct: "ArrayList основан на динамическом массиве, а LinkedList - на двусвязном списке, что влияет на производительность операций",
      incorrect: "Неверно, основное различие в структуре данных: ArrayList использует массив, а LinkedList - двусвязный список"
    }
  },
  {
    question: "Что такое autoboxing и unboxing в Java?",
    options: [
      "Автоматическое преобразование между примитивами и их обертками",
      "Упаковка приложения",
      "Оптимизация памяти",
      "Шифрование данных"
    ],
    answer: "Автоматическое преобразование между примитивами и их обертками",
    explanation: {
      correct: "Autoboxing - автоматическое преобразование примитива в объект-обертку, unboxing - обратный процесс",
      incorrect: "Неверно, autoboxing и unboxing - это автоматическое преобразование между примитивными типами и их классами-обертками"
    }
  },
  {
    question: "Как работает сборщик мусора (Garbage Collector) в Java?",
    options: [
      "Автоматически освобождает память от недостижимых объектов",
      "Удаляет все объекты после выполнения программы",
      "Требует ручного вызова",
      "Работает только с примитивами"
    ],
    answer: "Автоматически освобождает память от недостижимых объектов",
    explanation: {
      correct: "GC автоматически находит и удаляет объекты, на которые нет ссылок, освобождая память",
      incorrect: "Неверно, сборщик мусора автоматически освобождает память от объектов, которые больше не используются"
    }
  },
  {
    question: "Что такое equals() и hashCode() и как они связаны?",
    options: [
      "Если два объекта равны по equals(), их hashCode() должен быть одинаковым",
      "hashCode() определяет порядок в коллекциях",
      "equals() используется только для примитивов",
      "hashCode() должен быть уникальным для каждого объекта"
    ],
    answer: "Если два объекта равны по equals(), их hashCode() должен быть одинаковым",
    explanation: {
      correct: "Согласно контракту, если объекты равны по equals(), их хеш-коды должны быть одинаковыми, иначе будут проблемы в хеш-коллекциях",
      incorrect: "Неверно, контракт требует, чтобы равные объекты имели одинаковый хеш-код для корректной работы в HashMap и HashSet"
    }
  },
  {
    question: "Чем отличается HashMap от TreeMap?",
    options: [
      "HashMap не упорядочен, TreeMap поддерживает сортировку",
      "HashMap синхронизирован, TreeMap - нет",
      "HashMap позволяет null, TreeMap - нет",
      "HashMap быстрее для поиска, TreeMap - для вставки"
    ],
    answer: "HashMap не упорядочен, TreeMap поддерживает сортировку",
    explanation: {
      correct: "HashMap не гарантирует порядок элементов, а TreeMap хранит элементы в отсортированном порядке по ключам",
      incorrect: "Неверно, основное различие в порядке: HashMap неупорядочен, TreeMap поддерживает сортировку ключей"
    }
  },
  {
    question: "Что такое synchronized в Java?",
    options: [
      "Ключевое слово для обеспечения потокобезопасности",
      "Метод для остановки потока",
      "Тип данных для многопоточности",
      "Аннотация для потоков"
    ],
    answer: "Ключевое слово для обеспечения потокобезопасности",
    explanation: {
      correct: "synchronized обеспечивает, что только один поток может выполнять метод или блок кода одновременно",
      incorrect: "Неверно, synchronized используется для создания потокобезопасного кода, позволяя только одному потоку выполнять блок кода"
    }
  },
  {
    question: "Что такое deadlock и как его избежать?",
    options: [
      "Ситуация, когда потоки взаимно блокируют друг друга, избегают фиксированным порядком захвата блокировок",
      "Ошибка памяти",
      "Зависание программы",
      "Проблема с сетью"
    ],
    answer: "Ситуация, когда потоки взаимно блокируют друг друга, избегают фиксированным порядком захвата блокировок",
    explanation: {
      correct: "Deadlock возникает, когда потоки ожидают блокировок друг у друга; избегают фиксированным порядком захвата ресурсов",
      incorrect: "Неверно, deadlock - это когда потоки взаимно блокируют друг друга, ожидая ресурсов; предотвращается фиксированным порядком захвата"
    }
  },
  {
    question: "Чем отличается fail-fast от fail-safe итераторов?",
    options: [
      "Fail-fast бросает исключение при модификации, fail-safe работает с копией",
      "Fail-fast быстрее",
      "Fail-safe требует синхронизации",
      "Fail-fast работает только с массивами"
    ],
    answer: "Fail-fast бросает исключение при модификации, fail-safe работает с копией",
    explanation: {
      correct: "Fail-fast итераторы бросают ConcurrentModificationException при изменении коллекции, fail-safe работают с копией данных",
      incorrect: "Неверно, fail-fast итераторы обнаруживают изменения и бросают исключение, а fail-safe работают с копией коллекции"
    }
  },
  {
    question: "Что такое try-with-resources в Java?",
    options: [
      "Автоматическое закрытие ресурсов, реализующих AutoCloseable",
      "Новый тип исключения",
      "Метод для управления памятью",
      "Способ обработки ошибок"
    ],
    answer: "Автоматическое закрытие ресурсов, реализующих AutoCloseable",
    explanation: {
      correct: "Try-with-resources автоматически закрывает ресурсы, реализующие интерфейс AutoCloseable, после выполнения блока",
      incorrect: "Неверно, try-with-resources обеспечивает автоматическое закрытие ресурсов, реализующих AutoCloseable"
    }
  },
  {
    question: "Чем отличается String, StringBuilder и StringBuffer?",
    options: [
      "String неизменяемый, StringBuilder несинхронизированный, StringBuffer синхронизированный",
      "String быстрее, остальные - медленнее",
      "StringBuilder позволяет null, StringBuffer - нет",
      "StringBuffer устарел"
    ],
    answer: "String неизменяемый, StringBuilder несинхронизированный, StringBuffer синхронизированный",
    explanation: {
      correct: "String - immutable, StringBuilder - mutable и несинхронизированный, StringBuffer - mutable и синхронизированный",
      incorrect: "Неверно, основные различия: изменяемость и потокобезопасность - String неизменяемый, StringBuilder несинхронизированный, StringBuffer синхронизированный"
    }
  },
  {
    question: "Что такое полиморфизм в Java?",
    options: [
      "Возможность объекта принимать разные формы",
      "Использование нескольких наследований",
      "Перегрузка операторов",
      "Скрытие данных"
    ],
    answer: "Возможность объекта принимать разные формы",
    explanation: {
      correct: "Полиморфизм позволяет объекту одного типа вести себя как объект другого типа через наследование и интерфейсы",
      incorrect: "Неверно, полиморфизм - это способность объекта принимать различные формы, например, через переопределение методов"
    }
  },
  {
    question: "Что такое внутренние классы (inner classes) в Java?",
    options: [
      "Классы, определенные внутри других классов",
      "Приватные классы",
      "Вложенные статические классы",
      "Классы в отдельных файлах"
    ],
    answer: "Классы, определенные внутри других классов",
    explanation: {
      correct: "Внутренние классы - это классы, определенные внутри других классов, имеющие доступ к членам внешнего класса",
      incorrect: "Неверно, внутренние классы - это классы, вложенные в другие классы и имеющие доступ к их членам"
    }
  },
  {
    question: "Что такое аннотации в Java?",
    options: [
      "Метаданные, добавляемые к коду",
      "Комментарии к коду",
      "Новые типы данных",
      "Методы для отладки"
    ],
    answer: "Метаданные, добавляемые к коду",
    explanation: {
      correct: "Аннотации предоставляют метаданные о коде, используемые компилятором, средой выполнения или фреймворками",
      incorrect: "Неверно, аннотации - это метаданные, которые добавляются к элементам кода и могут обрабатываться во время компиляции или выполнения"
    }
  },
  {
    question: "Чем отличается интерфейс от абстрактного класса?",
    options: [
      "Интерфейс может содержать только абстрактные методы (до Java 8), абстрактный класс - и реализации",
      "Абстрактный класс быстрее",
      "Интерфейс позволяет множественное наследование реализации",
      "Абстрактный класс не может иметь конструктор"
    ],
    answer: "Интерфейс может содержать только абстрактные методы (до Java 8), абстрактный класс - и реализации",
    explanation: {
      correct: "Интерфейс изначально содержал только абстрактные методы, абстрактный класс может иметь как абстрактные, так и реализованные методы",
      incorrect: "Неверно, основное различие - в возможности реализации: абстрактный класс может содержать реализованные методы, интерфейс - нет (до Java 8)"
    }
  },
  {
    question: "Что такое generics в Java?",
    options: [
      "Позволяют создавать классы, интерфейсы и методы с типами, определяемыми при использовании",
      "Обобщенные методы",
      "Универсальные классы",
      "Типы для коллекций"
    ],
    answer: "Позволяют создавать классы, интерфейсы и методы с типами, определяемыми при использовании",
    explanation: {
      correct: "Generics позволяют писать обобщенный код, который работает с разными типами, обеспечивая типовую безопасность на этапе компиляции",
      incorrect: "Неверно, generics - это механизм обобщенного программирования, позволяющий создавать типобезопасный код с параметризованными типами"
    }
  },
  {
    question: "Что такое lambda-выражения в Java?",
    options: [
      "Анонимные функции, реализующие функциональные интерфейсы",
      "Новые типы данных",
      "Методы для многопоточности",
      "Способ оптимизации"
    ],
    answer: "Анонимные функции, реализующие функциональные интерфейсы",
    explanation: {
      correct: "Lambda-выражения позволяют реализовать функциональные интерфейсы (с одним абстрактным методом) в компактной форме",
      incorrect: "Неверно, lambda-выражения - это компактный способ реализации функциональных интерфейсов без явного создания анонимных классов"
    }
  },
  {
    question: "Что такое Stream API в Java?",
    options: [
      "API для обработки последовательностей данных",
      "Потоки ввода-вывода",
      "Многопоточность",
      "Сетевые потоки"
    ],
    answer: "API для обработки последовательностей данных",
    explanation: {
      correct: "Stream API предоставляет функциональные возможности для обработки последовательностей данных, таких как фильтрация, преобразование и агрегация",
      incorrect: "Неверно, Stream API - это набор инструментов для функциональной обработки данных, а не для ввода-вывода"
    }
  },
  {
    question: "Что такое Optional в Java?",
    options: [
      "Контейнер, который может содержать или не содержать значение",
      "Новый тип данных",
      "Метод для проверки null",
      "Аннотация для полей"
    ],
    answer: "Контейнер, который может содержать или не содержать значение",
    explanation: {
      correct: "Optional - это контейнер, который помогает избежать NullPointerException, явно указывая, что значение может отсутствовать",
      incorrect: "Неверно, Optional - это обертка, которая может содержать значение или быть пустой, помогая избежать NullPointerException"
    }
  },
  {
    question: "Чем отличается shallow copy от deep copy?",
    options: [
      "Shallow copy копирует ссылки, deep copy - объекты рекурсивно",
      "Shallow copy быстрее",
      "Deep copy требует больше памяти",
      "Shallow copy не работает с коллекциями"
    ],
    answer: "Shallow copy копирует ссылки, deep copy - объекты рекурсивно",
    explanation: {
      correct: "При shallow copy копируются только ссылки на объекты, при deep copy создаются копии всех вложенных объектов",
      incorrect: "Неверно, основное различие в глубине копирования: shallow копирует ссылки, deep - рекурсивно копирует все объекты"
    }
  },
  {
    question: "Что такое classloader в Java?",
    options: [
      "Компонент, загружающий классы в JVM",
      "Компилятор классов",
      "Менеджер памяти",
      "Система безопасности"
    ],
    answer: "Компонент, загружающий классы в JVM",
    explanation: {
      correct: "ClassLoader отвечает за загрузку классов в виртуальную машину Java во время выполнения программы",
      incorrect: "Неверно, ClassLoader - это система, отвечающая за загрузку классов в JVM по их имени"
    }
  },
  {
    question: "Что такое reflection в Java?",
    options: [
      "Возможность анализировать и модифицировать классы, методы, поля во время выполнения",
      "Отражение ошибок",
      "Метод оптимизации",
      "Система логирования"
    ],
    answer: "Возможность анализировать и модифицировать классы, методы, поля во время выполнения",
    explanation: {
      correct: "Reflection позволяет получать информацию о классах и их членах, а также создавать объекты и вызывать методы динамически",
      incorrect: "Неверно, reflection - это механизм, позволяющий анализировать и модифицировать структуру классов во время выполнения"
    }
  },
  {
    question: "Что такое volatile в Java?",
    options: [
      "Ключевое слово, гарантирующее видимость изменений между потоками",
      "Метод для остановки потока",
      "Тип переменной",
      "Аннотация для полей"
    ],
    answer: "Ключевое слово, гарантирующее видимость изменений между потоками",
    explanation: {
      correct: "Volatile гарантирует, что изменения переменной будут видны всем потокам и предотвращает кэширование переменной в регистрах",
      incorrect: "Неверно, volatile обеспечивает видимость изменений переменной между потоками и предотвращает оптимизации компилятора"
    }
  },
  {
    question: "Что такое thread pool в Java?",
    options: [
      "Группа переиспользуемых потоков для выполнения задач",
      "Сборник потоков",
      "Метод синхронизации",
      "Система управления потоками"
    ],
    answer: "Группа переиспользуемых потоков для выполнения задач",
    explanation: {
      correct: "Thread pool - это пул потоков, которые могут быть переиспользованы для выполнения нескольких задач, что эффективнее создания новых потоков",
      incorrect: "Неверно, thread pool - это пул потоков, которые переиспользуются для выполнения задач, что снижает накладные расходы на создание потоков"
    }
  },
  {
    question: "Что такое ConcurrentHashMap?",
    options: [
      "Потокобезопасная реализация Map с высокой производительностью",
      "Синхронизированная HashMap",
      "Новая версия HashMap",
      "Класс для работы с конфликтами"
    ],
    answer: "Потокобезопасная реализация Map с высокой производительностью",
    explanation: {
      correct: "ConcurrentHashMap обеспечивает потокобезопасность без блокировки всей таблицы, используя сегментирование для высокой производительности",
      incorrect: "Неверно, ConcurrentHashMap - это потокобезопасная коллекция, которая обеспечивает высокую производительность при многопоточном доступе"
    }
  },
  {
    question: "Что такое serialVersionUID?",
    options: [
      "Идентификатор версии класса для сериализации",
      "Уникальный ID объекта",
      "Код безопасности",
      "Хеш-код класса"
    ],
    answer: "Идентификатор версии класса для сериализации",
    explanation: {
      correct: "serialVersionUID используется при сериализации для проверки совместимости версий класса при десериализации",
      incorrect: "Неверно, serialVersionUID - это идентификатор версии класса, используемый для контроля совместимости при сериализации"
    }
  },
  {
    question: "Что такое dependency injection?",
    options: [
      "Передача зависимостей объекту извне, а не создание их внутри",
      "Внедрение кода",
      "Зависимость между классами",
      "Метод наследования"
    ],
    answer: "Передача зависимостей объекту извне, а не создание их внутри",
    explanation: {
      correct: "Dependency injection - это принцип, при котором объекту передаются его зависимости, а не создавать их самостоятельно",
      incorrect: "Неверно, dependency injection - это паттерн, при котором зависимости предоставляются объекту извне, а не создаются внутри него"
    }
  },
  {
    question: "Что такое SOLID принципы?",
    options: [
      "Набор принципов объектно-ориентированного проектирования",
      "Методы оптимизации",
      "Правила безопасности",
      "Стандарты кодирования"
    ],
    answer: "Набор принципов объектно-ориентированного проектирования",
    explanation: {
      correct: "SOLID - это акроним для пяти принципов ООП: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion",
      incorrect: "Неверно, SOLID - это набор пяти ключевых принципов объектно-ориентированного проектирования"
    }
  },
  {
    question: "Что такое ORM в Java?",
    options: [
      "Технология сопоставления объектов с реляционными базами данных",
      "Объектно-ориентированный язык",
      "Метод оптимизации",
      "Система управления объектами"
    ],
    answer: "Технология сопоставления объектов с реляционными базами данных",
    explanation: {
      correct: "ORM (Object-Relational Mapping) позволяет работать с базой данных в объектном стиле, преобразуя объекты в таблицы и обратно",
      incorrect: "Неверно, ORM - это технология, которая преобразует данные между несовместимыми системами типов в объектно-ориентированных языках и реляционных базах данных"
    }
  },
  {
    question: "Что такое JVM heap и stack?",
    options: [
      "Heap для объектов, stack для локальных переменных и вызовов методов",
      "Два типа коллекций",
      "Методы сортировки",
      "Типы памяти для примитивов"
    ],
    answer: "Heap для объектов, stack для локальных переменных и вызовов методов",
    explanation: {
      correct: "Heap используется для хранения объектов, stack - для хранения локальных переменных и информации о вызовах методов",
      incorrect: "Неверно, heap - это область памяти для объектов, stack - для локальных переменных и вызовов методов"
    }
  }
];