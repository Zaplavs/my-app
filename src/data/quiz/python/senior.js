export default [
  {
    question: "Что такое дескриптор с состоянием и как он отличается от обычного дескриптора?",
    options: [
      "Дескриптор, хранящий данные в экземпляре класса",
      "Дескриптор, хранящий данные в самом дескрипторе, а не в экземпляре",
      "Дескриптор, который не может хранить данные",
      "Дескриптор, использующий глобальные переменные"
    ],
    answer: "Дескриптор, хранящий данные в самом дескрипторе, а не в экземпляре",
    explanation: {
      correct: "Дескриптор с состоянием хранит данные в самом экземпляре дескриптора, что приводит к общему состоянию для всех экземпляров класса. Обычный дескриптор хранит данные в __dict__ экземпляра класса, обеспечивая изоляцию состояния.",
      incorrect: "Неверно. Ключевое отличие в том, где хранится состояние - в дескрипторе (общее) или в экземпляре (изолированное)."
    }
  },
  {
    question: "Как работает протокол дескриптора при доступе к атрибутам через класс и экземпляр?",
    options: [
      "Работает только для экземпляров",
      "Работает только для классов",
      "Работает по-разному: для экземпляра вызывается __get__ с obj и objtype, для класса - с None и objtype",
      "Не работает при доступе через класс"
    ],
    answer: "Работает по-разному: для экземпляра вызывается __get__ с obj и objtype, для класса - с None и objtype",
    explanation: {
      correct: "Протокол дескриптора различает доступ через экземпляр и через класс. При доступе через экземпляр __get__ получает экземпляр и класс, при доступе через класс - None и класс. Это позволяет реализовывать разное поведение.",
      incorrect: "Неверно. Протокол дескриптора работает в обоих случаях, но с разными аргументами, что позволяет гибкое управление поведением."
    }
  },
  {
    question: "Что такое MRO (Method Resolution Order) в Python и как реализован C3-линеаризация?",
    options: [
      "Случайный порядок поиска методов",
      "Простой обход в глубину",
      "Алгоритм топологической сортировки, сохраняющий порядок появления классов и монотонность",
      "Обход в ширину"
    ],
    answer: "Алгоритм топологической сортировки, сохраняющий порядок появления классов и монотонность",
    explanation: {
      correct: "MRO использует C3-линеаризацию - алгоритм топологической сортировки, который создает линейный порядок классов, сохраняя порядок появления в списках родителей и обеспечивая монотонность. Это решает проблемы ромбовидного наследования.",
      incorrect: "Неверно. C3-линеаризация - сложный алгоритм, а не простой обход, который решает проблемы множественного наследования."
    }
  },
  {
    question: "Как Python обрабатывает атрибуты при использовании __slots__ и что происходит с __dict__?",
    options: [
      "__slots__ добавляет новые атрибуты к __dict__",
      "__slots__ заменяет __dict__ на кортеж имен атрибутов, запрещая динамическое добавление атрибутов",
      "__slots__ создает отдельный словарь для слотов",
      "__slots__ не влияет на __dict__"
    ],
    answer: "__slots__ заменяет __dict__ на кортеж имен атрибутов, запрещая динамическое добавление атрибутов",
    explanation: {
      correct: "Когда используется __slots__, Python не создает __dict__ для экземпляра, а вместо этого выделяет память только для указанных атрибутов. Это экономит память и ускоряет доступ к атрибутам, но запрещает добавление новых атрибутов.",
      incorrect: "Неверно. __slots__ именно заменяет __dict__ и предотвращает динамическое добавление атрибутов, что является его основной целью."
    }
  },
  {
    question: "Как работает циклический сборщик мусора в Python и какие объекты он обрабатывает?",
    options: [
      "Удаляет все неиспользуемые объекты",
      "Работает только с простыми типами данных",
      "Обнаруживает и удаляет циклические ссылки между объектами, которые недостижимы из корней",
      "Работает только с встроенными типами"
    ],
    answer: "Обнаруживает и удаляет циклические ссылки между объектами, которые недостижимы из корней",
    explanation: {
      correct: "Сборщик мусора в Python использует алгоритм отслеживания ссылок и дополнительный циклический сборщик, который находит группы объектов с циклическими ссылками, которые недостижимы из корней (глобальные переменные, стек вызовов и т.д.) и освобождает их память.",
      incorrect: "Неверно. Основная задача циклического сборщика - именно обработка циклических ссылок, которые обычный счетчик ссылок не может обработать."
    }
  },
  {
    question: "Что такое зеркальные методы (reflected methods) в Python и когда они вызываются?",
    options: [
      "Методы, вызываемые при ошибке",
      "Вторичные методы (например, __radd__), вызываемые, когда основной метод (например, __add__) вернул NotImplemented",
      "Методы для отражения объектов",
      "Скрытые методы"
    ],
    answer: "Вторичные методы (например, __radd__), вызываемые, когда основной метод (например, __add__) вернул NotImplemented",
    explanation: {
      correct: "Зеркальные методы (с префиксом 'r') вызываются, когда основной метод возвращает NotImplemented, позволяя правому операнду попробовать выполнить операцию. Это обеспечивает правильную работу с операциями между разными типами.",
      incorrect: "Неверно. Зеркальные методы - это механизм для поддержки операций между разными типами, когда левый операнд не может обработать операцию."
    }
  },
  {
    question: "Как Python реализует интерфейс последовательности и какие методы необходимы?",
    options: [
      "Только __getitem__",
      "__getitem__ и __len__",
      "__getitem__, __len__ и __setitem__",
      "__iter__, __next__ и __len__"
    ],
    answer: "__getitem__ и __len__",
    explanation: {
      correct: "Для реализации интерфейса последовательности достаточно __getitem__ и __len__. Python может автоматически реализовать итерацию, проверку на вхождение и другие операции на основе этих двух методов.",
      incorrect: "Неверно. Хотя __setitem__ нужен для изменяемых последовательностей, для базового интерфейса достаточно __getitem__ и __len__."
    }
  },
  {
    question: "Что такое метапрограммирование в Python и какие инструменты для этого доступны?",
    options: [
      "Написание программ на другом языке",
      "Изменение поведения программы во время выполнения с помощью метаклассов, декораторов, __getattr__ и др.",
      "Использование специальных комментариев",
      "Оптимизация кода"
    ],
    answer: "Изменение поведения программы во время выполнения с помощью метаклассов, декораторов, __getattr__ и др.",
    explanation: {
      correct: "Метапрограммирование - это написание кода, который создает или модифицирует другой код во время выполнения. В Python для этого используются метаклассы, декораторы, динамическое создание классов, __getattr__, __getattribute__ и другие механизмы.",
      incorrect: "Неверно. Метапрограммирование - это именно изменение поведения программы во время выполнения с помощью специальных Python-механизмов."
    }
  },
  {
    question: "Как работает протокол итератора и в чем разница между итератором и итерируемым объектом?",
    options: [
      "Итератор и итерируемый - это одно и то же",
      "Итерируемый имеет __iter__, возвращающий итератор, который имеет __iter__ и __next__",
      "Итератор имеет __iter__, итерируемый - __next__",
      "Разницы нет"
    ],
    answer: "Итерируемый имеет __iter__, возвращающий итератор, который имеет __iter__ и __next__",
    explanation: {
      correct: "Итерируемый объект реализует __iter__, возвращающий итератор. Итератор реализует __iter__ (возвращающий себя) и __next__ (возвращающий следующий элемент или вызывающий StopIteration). Это позволяет одному итератору проходить по данным один раз.",
      incorrect: "Неверно. Это два разных понятия с разными протоколами, хотя и тесно связанные между собой."
    }
  },
  {
    question: "Что такое дескриптор данных (data descriptor) и как он влияет на поиск атрибутов?",
    options: [
      "Любой дескриптор",
      "Дескриптор с __get__ и __set__ или __delete__, имеющий приоритет над __dict__ экземпляра",
      "Дескриптор только с __get__",
      "Дескриптор, хранящий данные в __dict__"
    ],
    answer: "Дескриптор с __get__ и __set__ или __delete__, имеющий приоритет над __dict__ экземпляра",
    explanation: {
      correct: "Дескриптор данных имеет приоритет в протоколе поиска атрибутов. Если в классе есть дескриптор данных с __set__, он будет использоваться вместо __dict__ экземпляра, даже если в __dict__ уже есть атрибут с таким именем.",
      incorrect: "Неверно. Только дескрипторы с __set__ или __delete__ являются дескрипторами данных и имеют повышенный приоритет."
    }
  },
  {
    question: "Как Python реализует свойства (property) и какие дескрипторы стоят за ними?",
    options: [
      "Специальный синтаксис без дескрипторов",
      "Класс property, реализующий протокол дескриптора",
      "Магические методы __getattr__ и __setattr__",
      "Глобальные переменные"
    ],
    answer: "Класс property, реализующий протокол дескриптора",
    explanation: {
      correct: "Свойства реализованы через класс property, который является дескриптором данных. Он использует протокол дескриптора, перехватывая доступ к атрибутам и вызывая соответствующие методы (getter, setter, deleter).",
      incorrect: "Неверно. Свойства - это именно дескрипторы, реализованные через класс property, а не просто магические методы."
    }
  },
  {
    question: "Что такое каррирование (currying) в функциональном программировании и как его реализовать в Python?",
    options: [
      "Преобразование функции с несколькими аргументами в последовательность функций с одним аргументом",
      "Создание декораторов",
      "Использование лямбда-функций",
      "Преобразование методов в функции"
    ],
    answer: "Преобразование функции с несколькими аргументами в последовательность функций с одним аргументом",
    explanation: {
      correct: "Каррирование - это преобразование функции от нескольких аргументов в цепочку функций, каждая из которых принимает один аргумент. В Python это можно реализовать с помощью замыканий или functools.partial.",
      incorrect: "Неверно. Каррирование - это именно преобразование многопараметрической функции в последовательность однопараметрических."
    }
  },
  {
    question: "Как работает протокол контекстного менеджера и какие методы он включает?",
    options: [
      "__enter__ и __exit__",
      "__open__ и __close__",
      "__start__ и __end__",
      "__init__ и __del__"
    ],
    answer: "__enter__ и __exit__",
    explanation: {
      correct: "Протокол контекстного менеджера требует реализации методов __enter__ (выполняется при входе в блок with) и __exit__ (выполняется при выходе, даже при исключениях). Это обеспечивает корректное управление ресурсами.",
      incorrect: "Неверно. Стандартные методы для контекстных менеджеров - __enter__ и __exit__, а не другие варианты."
    }
  },
  {
    question: "Что такое мемоизация и как она может быть реализована в Python?",
    options: [
      "Удаление кэша",
      "Кэширование результатов функций для избежания повторных вычислений",
      "Шифрование данных",
      "Оптимизация памяти"
    ],
    answer: "Кэширование результатов функций для избежания повторных вычислений",
    explanation: {
      correct: "Мемоизация - это техника оптимизации, при которой результаты функции кэшируются на основе аргументов. При повторных вызовах с теми же аргументами возвращается закэшированный результат. В Python можно использовать декораторы или functools.lru_cache.",
      incorrect: "Неверно. Мемоизация - это именно кэширование результатов для ускорения выполнения."
    }
  },
  {
    question: "Как Python обрабатывает исключения в деструкторах и почему это проблема?",
    options: [
      "Исключения в деструкторах игнорируются",
      "Исключения в деструкторах могут быть перехвачены",
      "Исключения в деструкторах подавляются, но выводятся в stderr, что может привести к потере информации",
      "Исключения в деструкторах вызывают немедленное завершение программы"
    ],
    answer: "Исключения в деструкторах подавляются, но выводятся в stderr, что может привести к потере информации",
    explanation: {
      correct: "Когда исключение возникает в __del__, оно подавляется, но сообщение выводится в stderr. Это сделано для предотвращения сложных ситуаций с уничтожением объектов, но может привести к трудноуловимым ошибкам, так как исключение не останавливает выполнение.",
      incorrect: "Неверно. Исключения в деструкторах подавляются, но не игнорируются полностью - они выводятся в stderr."
    }
  },
  {
    question: "Что такое метакласс по умолчанию и как он создает классы?",
    options: [
      "object",
      "type",
      "class",
      "metaclass"
    ],
    answer: "type",
    explanation: {
      correct: "По умолчанию все классы создаются с помощью метакласса type. Когда вы определяете класс, Python вызывает type(name, bases, dict) для создания объекта класса. Type является одновременно классом и метаклассом.",
      incorrect: "Неверно. Метакласс по умолчанию - это type, а не object или другие варианты."
    }
  },
  {
    question: "Как работает протокол сериализации pickle и какие методы можно реализовать для кастомизации?",
    options: [
      "__pickle__ и __unpickle__",
      "__serialize__ и __deserialize__",
      "__getstate__ и __setstate__",
      "__dump__ и __load__"
    ],
    answer: "__getstate__ и __setstate__",
    explanation: {
      correct: "Для кастомизации сериализации с помощью pickle можно реализовать __getstate__ (возвращает объект, который будет сериализован) и __setstate__ (восстанавливает состояние из десериализованного объекта). Это позволяет контролировать процесс сериализации.",
      incorrect: "Неверно. Стандартные методы для кастомизации pickle - __getstate__ и __setstate__."
    }
  },
  {
    question: "Что такое ленивая загрузка (lazy loading) и как ее реализовать в Python?",
    options: [
      "Загрузка всех данных при старте",
      "Отложенная инициализация атрибутов при первом доступе к ним",
      "Удаление неиспользуемых данных",
      "Кэширование в памяти"
    ],
    answer: "Отложенная инициализация атрибутов при первом доступе к ним",
    explanation: {
      correct: "Ленивая загрузка - это паттерн, при котором ресурсоемкая операция (например, загрузка данных) откладывается до момента первого использования. В Python это можно реализовать с помощью дескрипторов или __getattr__, инициализирующих атрибут при первом доступе.",
      incorrect: "Неверно. Ленивая загрузка - это именно отложенная инициализация при первом доступе, а не немедленная загрузка."
    }
  },
  {
    question: "Как Python реализует множественное наследование и как определяется порядок разрешения методов?",
    options: [
      "Случайный порядок",
      "Только последний класс в списке",
      "С помощью MRO (Method Resolution Order) с алгоритмом C3",
      "По алфавитному порядку"
    ],
    answer: "С помощью MRO (Method Resolution Order) с алгоритмом C3",
    explanation: {
      correct: "Python использует MRO с алгоритмом C3 для определения порядка поиска методов в иерархии множественного наследования. Это обеспечивает предсказуемый и логичный порядок, решая проблемы ромбовидного наследования.",
      incorrect: "Неверно. Порядок определяется сложным алгоритмом C3, а не случайно или по простым правилам."
    }
  },
  {
    question: "Что такое дескриптор только для чтения и как его реализовать?",
    options: [
      "Дескриптор без __get__",
      "Дескриптор с __get__, но без __set__",
      "Дескриптор с __set__ и __delete__",
      "Дескриптор с __readonly__"
    ],
    answer: "Дескриптор с __get__, но без __set__",
    explanation: {
      correct: "Дескриптор только для чтения реализуется с помощью метода __get__, но без __set__. При попытке присвоения значения будет использоваться обычный механизм __dict__ экземпляра, но дескриптор будет иметь приоритет при чтении.",
      incorrect: "Неверно. Дескриптор только для чтения - это дескриптор с __get__ и без __set__, что позволяет читать, но не изменять значение через дескриптор."
    }
  }
];