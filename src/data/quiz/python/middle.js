export default [
  {
    question: "Что выведет следующий код: [x**2 for x in range(5)]?",
    options: ["[0, 1, 4, 9, 16]", "[1, 4, 9, 16, 25]", "[0, 1, 2, 3, 4]", "[1, 2, 3, 4, 5]"],
    answer: "[0, 1, 4, 9, 16]",
    explanation: {
      correct: "Генератор списка возводит в квадрат каждое число от 0 до 4 (range(5) генерирует 0,1,2,3,4). 0²=0, 1²=1, 2²=4, 3²=9, 4²=16.",
      incorrect: "Неверно. range(5) начинается с 0, а не с 1, и квадрат 0 равен 0."
    }
  },
  {
    question: "Что такое декоратор в Python?",
    options: ["Специальный комментарий", "Функция, которая принимает другую функцию и расширяет её поведение", "Тип данных", "Оператор"],
    answer: "Функция, которая принимает другую функцию и расширяет её поведение",
    explanation: {
      correct: "Декоратор - это функция, которая принимает другую функцию в качестве аргумента и возвращает новую функцию с расширенным или измененным поведением, не изменяя оригинал.",
      incorrect: "Неверно. Декоратор - это функция высшего порядка, которая модифицирует поведение других функций."
    }
  },
  {
    question: "Что выведет print('Hello'.replace('l', 'L', 1))?",
    options: ["HeLLo", "Hello", "HeLlo", "HELLO"],
    answer: "HeLlo",
    explanation: {
      correct: "Метод replace() с аргументом count=1 заменяет только первое вхождение 'l' на 'L'. Первое 'l' находится на позиции 2, поэтому получаем 'HeLlo'.",
      incorrect: "Неверно. Третий аргумент 1 ограничивает замену только первым вхождением символа."
    }
  },
  {
    question: "Как правильно создать генератор в Python?",
    options: ["Используя квадратные скобки []", "Используя круглые скобки ()", "Используя ключевое слово yield", "Используя функцию generator()"],
    answer: "Используя ключевое слово yield",
    explanation: {
      correct: "Генератор создается с помощью функции, содержащей ключевое слово yield. При вызове такая функция возвращает объект-генератор, который можно итерировать.",
      incorrect: "Неверно. yield - это ключевое слово для создания генераторов, () создает генераторное выражение, но не функцию-генератор."
    }
  },
  {
    question: "Что делает оператор 'is' в Python?",
    options: ["Сравнивает значения", "Сравнивает идентичность объектов (ссылаются ли на один и тот же объект в памяти)", "Проверяет тип данных", "Определяет наличие элемента"],
    answer: "Сравнивает идентичность объектов (ссылаются ли на один и тот же объект в памяти)",
    explanation: {
      correct: "Оператор 'is' проверяет, являются ли два объекта одним и тем же объектом в памяти (имеют ли одинаковый идентификатор). Это отличается от ==, который сравнивает значения.",
      incorrect: "Неверно. 'is' сравнивает идентичность объектов, а не их значения."
    }
  },
  {
    question: "Что такое *args в функции Python?",
    options: ["Способ передачи ключевых аргументов", "Способ передачи переменного числа позиционных аргументов", "Специальный тип данных", "Оператор умножения"],
    answer: "Способ передачи переменного числа позиционных аргументов",
    explanation: {
      correct: "*args позволяет функции принимать любое количество позиционных аргументов. Все переданные аргументы собираются в кортеж с именем args.",
      incorrect: "Неверно. *args используется для позиционных аргументов, **kwargs - для ключевых."
    }
  },
  {
    question: "Что выведет следующий код: print(bool(''))?",
    options: ["True", "False", "None", "Ошибка"],
    answer: "False",
    explanation: {
      correct: "Пустая строка в Python является 'ложной' (falsy) в булевом контексте. Все пустые коллекции и строки с нулевой длиной возвращают False при преобразовании в bool.",
      incorrect: "Неверно. Пустая строка считается ложной в булевом контексте."
    }
  },
  {
    question: "Как правильно использовать менеджер контекста в Python?",
    options: ["with open('file.txt') as f:", "context open('file.txt') as f:", "try open('file.txt') as f:", "using open('file.txt') as f:"],
    answer: "with open('file.txt') as f:",
    explanation: {
      correct: "Ключевое слово 'with' используется для создания менеджера контекста, который автоматически управляет ресурсами (например, файлами), обеспечивая их правильное закрытие после использования.",
      incorrect: "Неверно. В Python для менеджеров контекста используется только конструкция 'with'."
    }
  },
  {
    question: "Что делает метод strip() для строки?",
    options: ["Разделяет строку на части", "Удаляет пробелы и символы-переносы в начале и конце строки", "Заменяет пробелы", "Преобразует в список"],
    answer: "Удаляет пробелы и символы-переносы в начале и конце строки",
    explanation: {
      correct: "Метод strip() удаляет все пробельные символы (пробелы, табуляции, символы новой строки) с обоих концов строки. Можно передать аргумент с символами для удаления.",
      incorrect: "Неверно. strip() удаляет пробелы с краев строки, а не разделяет её."
    }
  },
  {
    question: "Что такое замыкание (closure) в Python?",
    options: ["Функция внутри функции", "Вложенная функция, которая имеет доступ к переменным из внешней функции", "Тип данных", "Оператор"],
    answer: "Вложенная функция, которая имеет доступ к переменным из внешней функции",
    explanation: {
      correct: "Замыкание - это вложенная функция, которая запоминает и имеет доступ к переменным из своей внешней области видимости, даже после того, как внешняя функция завершила выполнение.",
      incorrect: "Неверно. Замыкание - это не просто вложенная функция, а функция, сохраняющая доступ к переменным внешней функции."
    }
  },
  {
    question: "Как правильно импортировать только определенную функцию из модуля?",
    options: ["import function from module", "from module import function", "require function from module", "using module.function"],
    answer: "from module import function",
    explanation: {
      correct: "Конструкция 'from module import function' позволяет импортировать только указанную функцию из модуля, что делает её доступной напрямую без указания имени модуля.",
      incorrect: "Неверно. Правильный синтаксис - 'from module import function'."
    }
  },
  {
    question: "Что выведет print([1, 2, 3] + [4, 5])?",
    options: ["[1, 2, 3, 4, 5]", "[5, 7, 3]", "[1, 2, 3][4, 5]", "Ошибка"],
    answer: "[1, 2, 3, 4, 5]",
    explanation: {
      correct: "Оператор + для списков выполняет конкатенацию (объединение). Он создает новый список, содержащий все элементы первого списка, за которыми следуют все элементы второго списка.",
      incorrect: "Неверно. + для списков означает объединение, а не поэлементное сложение."
    }
  },
  {
    question: "Что такое магические методы в Python?",
    options: ["Секретные функции", "Методы с двумя подчеркиваниями в начале и конце, определяющие поведение объектов", "Особые типы данных", "Операторы"],
    answer: "Методы с двумя подчеркиваниями в начале и конце, определяющие поведение объектов",
    explanation: {
      correct: "Магические методы (или дандер-методы) - это специальные методы с двойными подчеркиваниями (например, __init__, __str__, __add__), которые определяют поведение объектов при использовании встроенных операций.",
      incorrect: "Неверно. Магические методы - это стандартные методы Python для определения поведения объектов."
    }
  },
  {
    question: "Как правильно создать класс в Python?",
    options: ["class MyClass:", "class MyClass()", "def class MyClass:", "create class MyClass:"],
    answer: "class MyClass:",
    explanation: {
      correct: "Классы в Python создаются с помощью ключевого слова 'class', за которым следует имя класса и двоеточие. Имя класса обычно пишется в CamelCase.",
      incorrect: "Неверно. Правильный синтаксис - 'class ClassName:' без скобок."
    }
  },
  {
    question: "Что делает метод get() для словаря?",
    options: ["Получает ключ", "Получает значение по ключу, возвращая None или значение по умолчанию, если ключ не найден", "Добавляет элемент", "Удаляет элемент"],
    answer: "Получает значение по ключу, возвращая None или значение по умолчанию, если ключ не найден",
    explanation: {
      correct: "Метод get() безопасно получает значение по ключу. Если ключ существует, возвращает его значение; если нет, возвращает None или указанное значение по умолчанию, не вызывая ошибку.",
      incorrect: "Неверно. get() безопасно получает значение, в отличие от прямого доступа по ключу, который вызывает KeyError."
    }
  },
  {
    question: "Что такое PIP в Python?",
    options: ["Интегрированная среда разработки", "Система управления пакетами", "Язык программирования", "Тип данных"],
    answer: "Система управления пакетами",
    explanation: {
      correct: "PIP - это стандартный менеджер пакетов для Python, используемый для установки и управления сторонними библиотеками и пакетами из Python Package Index (PyPI).",
      incorrect: "Неверно. PIP - это менеджер пакетов, а не IDE или язык программирования."
    }
  },
  {
    question: "Что выведет print('Python'[1:4])?",
    options: ["yth", "ytho", "Pyt", "thon"],
    answer: "yth",
    explanation: {
      correct: "Срез [1:4] означает взять символы с индекса 1 (включительно) по индекс 4 (исключительно). В строке 'Python' индексы: P=0, y=1, t=2, h=3, o=4, n=5. Поэтому получаем 'yth'.",
      incorrect: "Неверно. Срез [1:4] включает индексы 1, 2, 3 и исключает 4."
    }
  },
  {
    question: "Как правильно обработать исключение в Python?",
    options: ["try-catch", "try-except", "if-error", "when-exception"],
    answer: "try-except",
    explanation: {
      correct: "В Python для обработки исключений используется конструкция try-except. Код, который может вызвать ошибку, помещается в блок try, а обработка ошибки - в блок except.",
      incorrect: "Неверно. В Python используется try-except, а не try-catch как в других языках."
    }
  },
  {
    question: "Что такое виртуальное окружение в Python?",
    options: ["Специальный тип данных", "Изолированная среда для проекта с собственными зависимостями", "Функция", "Оператор"],
    answer: "Изолированная среда для проекта с собственными зависимостями",
    explanation: {
      correct: "Виртуальное окружение позволяет создать изолированное пространство для проекта с собственным набором пакетов и зависимостей, не влияя на глобальную установку Python.",
      incorrect: "Неверно. Виртуальное окружение - это изолированная среда для управления зависимостями проекта."
    }
  },
  {
    question: "Что делает функция map() в Python?",
    options: ["Фильтрует элементы", "Применяет функцию к каждому элементу последовательности", "Сортирует элементы", "Объединяет последовательности"],
    answer: "Применяет функцию к каждому элементу последовательности",
    explanation: {
      correct: "Функция map() принимает функцию и итерируемый объект, применяет функцию к каждому элементу и возвращает итератор с результатами. Это функциональный подход к преобразованию данных.",
      incorrect: "Неверно. map() применяет функцию к каждому элементу, filter() фильтрует, sorted() сортирует."
    }
  },
  {
    question: "Что такое __init__.py в папке Python?",
    options: ["Файл для инициализации переменных", "Файл, который делает папку пакетом", "Специальный тип данных", "Оператор"],
    answer: "Файл, который делает папку пакетом",
    explanation: {
      correct: "Файл __init__.py (даже пустой) указывает Python, что каталог является пакетом и может быть импортирован. В современных версиях Python (3.3+) он не обязателен, но часто используется.",
      incorrect: "Неверно. Основное назначение __init__.py - сделать каталог пакетом для импорта."
    }
  },
  {
    question: "Как правильно создать словарь с помощью генератора?",
    options: ["{x: x**2 for x in range(5)}", "[x: x**2 for x in range(5)]", "(x: x**2 for x in range(5))", "{x => x**2 for x in range(5)}"],
    answer: "{x: x**2 for x in range(5)}",
    explanation: {
      correct: "Генератор словаря использует фигурные скобки {} и синтаксис ключ: значение. В примере создается словарь с ключами от 0 до 4 и их квадратами в качестве значений.",
      incorrect: "Неверно. Генераторы словарей используют фигурные скобки и синтаксис ключ: значение."
    }
  },
  {
    question: "Что делает ключевое слово 'global' в Python?",
    options: ["Создает глобальную переменную", "Позволяет изменять глобальную переменную внутри функции", "Определяет тип данных", "Импортирует модуль"],
    answer: "Позволяет изменять глобальную переменную внутри функции",
    explanation: {
      correct: "Ключевое слово 'global' сообщает Python, что внутри функции нужно использовать глобальную переменную с указанным именем, а не создавать локальную. Это позволяет изменять глобальные переменные.",
      incorrect: "Неверно. 'global' не создает переменную, а позволяет доступ к существующей глобальной переменной."
    }
  },
  {
    question: "Что такое GIL в Python?",
    options: ["Графический интерфейс", "Глобальная блокировка интерпретатора", "Библиотека для работы с изображениями", "Тип данных"],
    answer: "Глобальная блокировка интерпретатора",
    explanation: {
      correct: "GIL (Global Interpreter Lock) - это мьютекс, который позволяет только одному потоку выполнять Python-байткод в один момент времени, что ограничивает многопоточность в CPython.",
      incorrect: "Неверно. GIL - это механизм синхронизации в интерпретаторе CPython, а не графический интерфейс."
    }
  },
  {
    question: "Как правильно использовать f-строки в Python?",
    options: ["'Hello {name}'.format(name='World')", "f'Hello {name}'", "'Hello %s' % 'World'", "string.format('Hello {name}')"],
    answer: "f'Hello {name}'",
    explanation: {
      correct: "F-строки (форматированные строковые литералы) создаются с префиксом 'f' и позволяют вставлять выражения в фигурные скобки. Это самый современный и эффективный способ форматирования строк.",
      incorrect: "Неверно. f-строки используют префикс 'f' перед строкой, а не метод format()."
    }
  },
  {
    question: "Что делает функция enumerate() в Python?",
    options: ["Создает словарь", "Возвращает индекс и значение для каждого элемента последовательности", "Фильтрует элементы", "Сортирует элементы"],
    answer: "Возвращает индекс и значение для каждого элемента последовательности",
    explanation: {
      correct: "Функция enumerate() добавляет счетчик к итерируемому объекту и возвращает его в виде объекта enumerate, который генерирует пары (индекс, значение). Удобно для циклов с индексами.",
      incorrect: "Неверно. enumerate() возвращает индексы и значения, а не создает словари или фильтрует данные."
    }
  },
  {
    question: "Что такое дескриптор в Python?",
    options: ["Специальный комментарий", "Объект, реализующий методы __get__, __set__ или __delete__", "Тип данных", "Оператор"],
    answer: "Объект, реализующий методы __get__, __set__ или __delete__",
    explanation: {
      correct: "Дескриптор - это объект, реализующий один из методов управления доступом к атрибутам: __get__, __set__ или __delete__. Они позволяют создавать кастомное поведение для атрибутов класса.",
      incorrect: "Неверно. Дескриптор - это объект с определенными магическими методами для управления атрибутами."
    }
  },
  {
    question: "Как правильно создать множество в Python?",
    options: ["set = [1, 2, 3]", "set = (1, 2, 3)", "set = {1, 2, 3}", "set = <1, 2, 3>"],
    answer: "set = {1, 2, 3}",
    explanation: {
      correct: "Множества в Python создаются с помощью фигурных скобок {} с элементами через запятую. Это неупорядоченная коллекция уникальных элементов, поддерживающая математические операции над множествами.",
      incorrect: "Неверно. Только фигурные скобки {} используются для создания множеств (кроме пустого множества, для которого нужен set())."
    }
  },
  {
    question: "Что делает метод join() для строки?",
    options: ["Объединяет строки из списка", "Разделяет строку", "Заменяет символы", "Удаляет пробелы"],
    answer: "Объединяет строки из списка",
    explanation: {
      correct: "Метод join() объединяет элементы последовательности (обычно списка строк) в одну строку, используя строку-разделитель. Например, ' '.join(['a', 'b']) вернет 'a b'.",
      incorrect: "Неверно. join() объединяет строки, а split() разделяет их."
    }
  },
  {
    question: "Что такое метакласс в Python?",
    options: ["Специальный тип комментариев", "Класс, который создает другие классы", "Тип данных", "Оператор"],
    answer: "Класс, который создает другие классы",
    explanation: {
      correct: "Метакласс - это класс классов. Когда вы создаете класс, Python использует метакласс (обычно type) для его создания. Метаклассы позволяют контролировать создание классов и изменять их поведение.",
      incorrect: "Неверно. Метакласс - это класс, который управляет созданием других классов."
    }
  }
];